# 入口文件整合规划报告

**版本**: v4.0  
**日期**: 2025-12-30  
**状态**: 📋 规划中（已根据第三十一轮审阅意见修订 + 关键实现问题修复）

---

## 修订记录

| 版本 | 日期 | 修订内容 |
|------|------|----------|
| v1.0 | 2025-12-29 | 初稿 |
| v1.1 | 2025-12-29 | 根据审阅意见修订：补充迁移顺序、运行契约、日志细节、兼容方案 |
| v1.2 | 2025-12-29 | 第二轮修订：修复 wrapper 参数透传、GameEngine 适配器 scene_id 映射、progress.json 版本兼容、日志级别定义、参数列表补全 |
| v1.3 | 2025-12-29 | 第三轮修订：统一 ProgressTracker 接口签名、ProgressData 类型定义、load_progress 显式补齐默认值、TURNS_PER_SCENE 可配置、Q2 弃用示例改用 stderr、8.4 表格升级为 v2 格式 |
| v1.4 | 2025-12-29 | 第四轮修订：save_progress 添加自动补齐字段说明及示例实现、load_resume_scene_id 明确复用 load_progress 逻辑 |
| v1.5 | 2025-12-29 | 第五轮修订：OSAgentSession.save() 添加 turn_count 传入、补充 resume() 方法实现示例及行为规范说明、添加 Q5/Q6 回答 |
| v1.6 | 2025-12-29 | 第六轮修订：修复 can_resume/resume 一致性问题、添加引擎选择优先级规则 (Q7)、添加引擎切换数据同步规则 (Q8) |
| v1.7 | 2025-12-29 | 第七轮修订：拆分 start()/resume() 避免副作用、补充边界测试清单 (B-06~B-13)、添加 Screen Agent 兼容性策略 (Q9) |
| v1.8 | 2025-12-29 | 第九轮修订：明确 play.py 固定 OS Agent（解决引擎矛盾）、区分 dev.py 新开局/续玩规则、统一 CLI 选项命名、定义 can_switch_engine 恢复时机、添加 JSON 损坏处理策略和测试 (B-14~B-16) |
| v1.9 | 2025-12-29 | 第十轮修订：统一 resolve_engine() 函数定义、区分 --resume/--continue-build 语义、添加 play.py 引擎切换后更新 progress.json、修复警告可见性（stderr）、添加 can_switch_engine=false 设置逻辑、完善 B-15/B-16 数据一致性说明 |
| v2.0 | 2025-12-29 | 第十一轮修订：play.py 切换前检查 can_switch_engine、GameEngine 持久化切换状态、--resume/--continue-build 参数约束、损坏处理 fail-fast 与时间戳备份、B-16 非交互式回退 |
| v2.1 | 2025-12-29 | 第十二轮修订：ProgressData 添加 is_corrupted 字段、save_progress 添加 can_switch_engine 参数、修复文件句柄泄漏(with 语句)、修复 GameEngine turn_count 来源、更新默认行为示例、CLI 参数列表添加约束说明 |
| v2.2 | 2025-12-29 | 第十三轮修订：OSAgentSession.save() 添加 can_switch_engine=True、GameEngineSession 统一使用内部字段(_turn_count/_next_scene_id)、统一 resolve_engine 判断逻辑(is not None)、更新历史摘要 |
| v2.3 | 2025-12-29 | 第十四轮修订：save() 添加 at_boundary 参数区分边界/中途、handle_resume 检查文件存在、load_resume_scene_id 检查 is_corrupted、统一 resolve_engine 签名(Optional[Path])、Q5 示例添加 can_switch_engine |
| v2.4 | 2025-12-29 | 第十五轮修订：更新模块提取列表 GameSession.save() 签名、修复 can-switch 状态表(区分 at_boundary)、Q8 代码片段添加 at_boundary、can_switch_engine() 检查 is_corrupted、_init_agents() 检查 is_corrupted、Q5 bullet 完善参数说明 |
| v2.5 | 2025-12-29 | 第十六轮修订：process_turn() 开始时持久化 can_switch_engine=false、can_switch_engine() 检查文件存在、GameEngineSession.resume() 检查 is_corrupted、resolve_engine() 检查 is_corrupted、统一模块清单参数命名(player_input/save_name) |
| v2.6 | 2025-12-29 | 第十七轮修订：can_resume() 同时检查存在性和 is_corrupted 保证契约、switch_engine() 显式传入 can_switch_engine=True、警告机制添加 is_corrupted 保护、process_turn() 回合结束后落盘防进度丢失 |
| v2.7 | 2025-12-29 | 第十八轮修订：process_turn() 回合结束根据 scene_ended 设置 can_switch_engine(边界=True)、Q5 更新持久化策略说明、B-07 拆分损坏场景(B-07a)、明确 scene_id 更新来源(loop_result) |
| v2.8 | 2025-12-29 | 第十九轮修订：next_scene_id 从 loop_result 获取(支持非线性场景)、统一边界检测来源(废弃 on_scene_end)、明确 run_scene_loop 返回约定、添加 get_resume_error() 方法解决 B-07a 提示路径 |
| v2.9 | 2025-12-29 | 第二十轮修订：OSAgentSession/GameEngineSession 实现 get_resume_error()、__init__ 添加 _next_scene_id、_init_agents 恢复 next_scene_id、所有保存点统一使用 _next_scene_id |
| v3.0 | 2025-12-29 | 第二十一轮修订：非边界时保持 _next_scene_id 不变(避免覆盖非线性路径)、引入 _check_resume_state() 避免重复 load_progress、Q6 添加 get_resume_error 调用时机指导 |
| v3.1 | 2025-12-29 | 第二十二轮修订：_check_resume_state() 添加实例级缓存(避免 load_progress 副作用)、Q6 添加缓存机制说明 |
| v3.2 | 2025-12-29 | 第二十三轮修订：GameSession 抽象基类和模块清单添加 invalidate_resume_cache()、GameEngineSession 恢复线性 _next_scene_id 更新(保证 next > current)、save() 内部自动调用缓存失效 |
| v3.3 | 2025-12-29 | 第二十四轮修订：GameEngineSession.start() 强制线性化 next_scene_id(不继承 progress 中可能的非线性值)、process_turn() 结束后调用缓存失效(与 save 一致) |
| v3.4 | 2025-12-29 | 第二十五轮修订：_init_agents() 添加 fail_on_corrupted 参数(区分新游戏/恢复场景)、process_turn() 开头和结束都调用缓存失效、添加 B-17 缓存失效测试用例 |
| v3.5 | 2025-12-29 | 第二十六轮修订：GameEngineSession.resume() 使用 get_resume_error() 获取具体原因、GameEngine 线性化添加已知限制说明、run_scene_loop 返回约定添加 success 条件、跨进程损坏文件处理说明、DEFAULT_CAN_SWITCH 改为 False(保守策略)、Q6 缓存失效点完善 |
| v3.6 | 2025-12-29 | 第二十七轮修订：Q5/Q8 示例添加 success 门控、ProgressData.can_switch_engine 默认值统一为 DEFAULT_CAN_SWITCH(False)、Q8 表格"初始状态"改为 false、风险章节添加"OS→GE→OS 非线性分支丢失" |
| v3.7 | 2025-12-29 | 第二十八轮修订：save_progress 默认 can_switch_engine=DEFAULT_CAN_SWITCH(False)、progress.json 示例区分"场景中途"和"边界点"、Q5 摘要添加 success 门控提醒 |
| v3.8 | 2025-12-29 | 第二十九轮修订：添加 B-18 测试(v1 进度缺字段兼容性)、progress.json 示例移除非法 // 注释、边界点示例 scene_id 体现推进 |
| v3.9 | 2025-12-29 | 第三十轮修订：B-18 改用 save(at_boundary=True) 固定触发、明确使用 OSAgentSession、版本标注改为"自 v3.6 起" |
| v4.0 | 2025-12-30 | 第三十一轮修订：修复 OSAgentSession 三大关键缺口（max_turns=1 问题、缺少 dispatch_script_to_actors、scene_finished vs scene_ended 字段名不匹配、缺少 process_scene_transition），更新 Q5/Q8 相关约定，添加 B-19/B-20/B-21 测试用例 |

---

## 0. 关键实现问题与修复（v4.0 新增）

> ⚠️ **重要**：在实际实现过程中发现的三大关键缺口，导致"NPC重复开场白、玩家输入没进流程、场景不推进"。

### 0.1 问题分析

| 问题 | 根因 | 影响 | 严重程度 |
|------|------|------|----------|
| **玩家输入没进入回合** | `run_scene_loop(max_turns=1)` | 玩家输入从未写入 SceneMemory，NPC 每次重复开场白 | 🔴 高 |
| **NPC 没有本幕目标/剧本** | 未调用 `dispatch_script_to_actors()` | NPC 只用通用提示词，不会按剧情推进 | 🔴 高 |
| **幕间推进失效** | 字段名不匹配 + 未调用 `process_scene_transition()` | 进度永远停在第 1 幕 | 🔴 高 |

### 0.2 问题详解

#### 问题 1：max_turns=1 导致玩家输入无法进入场景循环

**现象**：
- 日志显示"下一位: user"后立刻"达到最大轮数限制 (1)"
- NPC 每次都从"第一位发言者"重开，反复说类似开场话术

**根因分析**：
```python
# 错误代码
loop_result = self.os_agent.run_scene_loop(
    ...,
    max_turns=1,  # ← 只允许 1 轮，NPC 说完就结束
    user_input_callback=lambda _: player_input,  # ← 从未被调用
    ...
)
```

`run_scene_loop()` 的流程：
1. 第一轮：NPC 发言
2. 路由决定下一位是 `user`
3. 检查 `turn_count >= max_turns` → 循环结束
4. 玩家的 `user_input_callback` **从未被调用**

**修复方案**：

```python
# 正确代码
loop_result = self.os_agent.run_scene_loop(
    ...,
    max_turns=3,  # ← NPC → User → NPC 完整交互
    user_input_callback=lambda _: player_input,
    ...
)
```

#### 问题 2：缺少 dispatch_script_to_actors() 调用

**现象**：
- 运行时目录只有 `history.json`，没有 `script.json`
- NPC 说话没有"本幕目标"，只是泛泛而谈

**根因分析**：
- `dispatch_script_to_actors()` 负责将 `current_script.json` 拆分为每个 NPC 的小剧本
- 小剧本包含 NPC 在本幕的目标、应该推动的情节等
- 没有调用 → NPC 只有通用角色提示词，没有剧情指引

**修复方案**：

```python
def _initialize_scene_and_get_opening(self) -> str:
    # 1. 确保 NPC 已初始化
    self.os_agent.ensure_scene_characters_initialized(...)
    
    # 2. 分发剧本给 NPC（关键！）
    self.os_agent.dispatch_script_to_actors(self.runtime_dir)
    
    # 3. 读取场景信息...
```

#### 问题 3：字段名不匹配 + 缺少幕间过渡

**现象**：
- 进度永远停在第 1 幕
- 即使 NPC 标记"场景结束"也不推进

**根因分析**：

1. **字段名不匹配**：
   - `run_scene_loop` 返回的是 `scene_finished`
   - 规划报告和代码写的是 `scene_ended`（不存在）
   
   ```python
   # run_scene_loop 返回：
   return {
       "scene_finished": scene_finished,  # ← 实际字段名
       ...
   }
   
   # 错误代码读取：
   is_scene_boundary = loop_result.get("scene_ended", False)  # ← 永远是 False
   ```

2. **缺少 process_scene_transition()**：
   - 旧的 `main_old.py` 中有调用
   - 新流程遗漏了这个关键步骤

**修复方案**：

```python
def process_turn(self, player_input: str) -> TurnResult:
    ...
    # 修复：使用正确的字段名 scene_finished
    is_scene_boundary = is_success and loop_result.get("scene_finished", False)
    
    # 修复：调用幕间过渡
    if is_scene_boundary:
        self._handle_scene_transition()
    ...

def _handle_scene_transition(self):
    """处理幕间过渡"""
    if hasattr(self.os_agent, 'process_scene_transition'):
        transition_result = self.os_agent.process_scene_transition(
            runtime_dir=self.runtime_dir,
            world_dir=self.world_dir
        )
        if transition_result.get("success"):
            self.current_scene_id = transition_result.get("next_scene_id", self.current_scene_id + 1)
            ...
```

### 0.3 run_scene_loop 返回约定（修订）

> ⚠️ **v4.0 重要修正**：返回字段是 `scene_finished`，不是 `scene_ended`

```python
# run_scene_loop 返回约定：
{
    "success": bool,           # 执行是否成功
    "total_turns": int,        # 本次执行的回合数
    "scene_finished": bool,    # ← 是否到达场景边界（幕间）
                               # ⚠️ 注意：不是 scene_ended！
    "dialogue_count": int,     # 对话数量
    "dialogue_history": list,  # 对话历史
    "final_status": str,       # 最终状态
    ...
}
```

### 0.4 相关测试用例（新增）

| 测试项 | 测试内容 | 验收标准 |
|--------|----------|----------|
| **B-19** | max_turns 配置 | max_turns >= 2 时，玩家输入能被写入 SceneMemory |
| **B-20** | 剧本分发 | start()/resume() 后，NPC 目录下有 script.json |
| **B-21** | 幕间推进 | scene_finished=True 时，current_scene_id 递增，process_scene_transition 被调用 |

---

## 1. 现有入口文件分析

### 1.1 现有入口清单

| 文件 | 定位 | 行数 | 核心功能 |
|------|------|------|----------|
| `main.py` | 游戏主入口 | 818 | 主菜单 + OS Agent流程 + Screen Agent |
| `play_game.py` | 交互式CLI | 463 | 世界/存档管理 + GameEngine |
| `run_game.py` | 自动化流程 | 502 | 三阶段流程 + 命令行参数 |
| `run_world_builder.py` | 世界构建器 | 1011 | 断点续传 + 并行化 + 交互菜单 |
| `run_creator_god.py` | 创世组入口 | 89 | 仅运行创世组 |
| `game_engine.py` | 游戏引擎 | 1829 | 核心引擎类（非入口） |

### 1.2 各入口优缺点分析

#### main.py
**优点**：
- ✅ 完整的OS Agent流程（与测试流程一致）
- ✅ 集成Screen Agent荧幕层渲染
- ✅ 支持场景演绎循环和幕间处理
- ✅ 支持创建新世界或选择已有世界
- ✅ 断点续传（load_resume_scene_id）
- ✅ 进度保存（save_progress）

**缺点**：
- ❌ 不使用GameEngine，与其他入口不一致
- ❌ 代码较长，混合了多种职责
- ❌ 缺少命令行参数支持
- ❌ 日志输出对玩家不够友好

#### play_game.py
**优点**：
- ✅ 清晰的世界/存档管理
- ✅ 玩家角色自定义
- ✅ 使用GameEngine（标准游戏循环）
- ✅ 行动建议功能
- ✅ 界面对玩家友好

**缺点**：
- ❌ 不支持创建新世界
- ❌ 不集成Screen Agent
- ❌ 缺少断点续传
- ❌ 缺少命令行参数

#### run_game.py
**优点**：
- ✅ 完整的三阶段流程
- ✅ 丰富的命令行参数
- ✅ 支持自动模式（测试用）
- ✅ 清晰的阶段划分

**缺点**：
- ❌ 使用GameEngine但不集成Screen Agent
- ❌ 缺少断点续传
- ❌ 世界选择逻辑较简单

#### run_world_builder.py
**优点**：
- ✅ 断点续传（Checkpoint机制）
- ✅ 并行化处理（Stage1+2并行，Stage3多角色并行）
- ✅ 交互式菜单（自动探测所有选项）
- ✅ 完整的世界列表展示
- ✅ 支持继续构建未完成的世界

**缺点**：
- ❌ 仅处理世界构建，不处理游戏运行
- ❌ 游戏启动部分代码不完整
- ❌ 依赖外部subprocess调用

#### run_creator_god.py
**优点**：
- ✅ 简单直接
- ✅ 专注单一功能

**缺点**：
- ❌ 功能太简单
- ❌ 被run_world_builder.py完全覆盖

---

## 2. 整合目标

### 2.1 最终入口文件

| 文件 | 定位 | 目标用户 | 核心理念 |
|------|------|----------|----------|
| `play.py` | 玩家入口 | 普通玩家 | 简洁、沉浸、隐藏技术细节 |
| `dev.py` | 开发者入口 | 开发/测试人员 | 详细、可控、支持调试 |

### 2.2 设计原则

**play.py（玩家入口）**：
1. **极简界面**：只展示游戏相关信息，隐藏所有技术日志
2. **沉浸体验**：Screen Agent渲染的电影质感输出
3. **智能引导**：自动检测可用世界，提供行动建议
4. **容错设计**：异常时给出友好提示，不暴露堆栈

**dev.py（开发者入口）**：
1. **完整日志**：显示所有Agent状态和调用链
2. **模块化控制**：可单独运行任意阶段
3. **调试支持**：断点续传、状态快照、性能计时
4. **命令行优先**：丰富的命令行参数

### 2.3 关键设计决策（审阅问答）

#### Q1: dev.py 无参数时默认走 OS Agent 还是 GameEngine？

**决策**：区分 **新开局** 和 **续玩** 两种场景。

**规则**：

| 场景 | 无 --engine 参数 | 有 --engine 参数 |
|------|-----------------|------------------|
| **新开局** | 默认 OS Agent | 使用指定引擎 |
| **续玩** | 继承 progress.json 的 engine_type | CLI 参数优先（覆盖进度引擎） |

**理由**：
- 新开局时默认 OS Agent，与 `main.py` 当前行为一致
- 续玩时继承上次引擎，保证存档连续性
- CLI 参数始终具有最高优先级，允许开发者强制切换

```bash
# 新开局
python dev.py                    # 默认 OS Agent
python dev.py --engine gameengine # 使用 GameEngine

# 续玩（--resume 必须配合 --runtime 指定运行时目录）
python dev.py --resume --runtime data/runtime/白鹿原_20251222  # 继承存档引擎
python dev.py --resume --runtime data/runtime/白鹿原_20251222 --engine osagent  # 强制切换
```

**参数约束**：
- `--resume` 和 `--continue-build` **互斥**（不能同时使用）
- `--resume` **必须**配合 `--runtime` 指定运行时目录
- `--continue-build` **必须**配合 `--stage genesis`
- 违反约束时立即报错退出，不静默回退

```python
# 参数验证
if args.resume and args.continue_build:
    print("❌ --resume 和 --continue-build 互斥", file=sys.stderr)
    sys.exit(1)

if args.resume and not args.runtime:
    print("❌ --resume 必须配合 --runtime 指定运行时目录", file=sys.stderr)
    sys.exit(1)

if args.continue_build and args.stage != "genesis":
    print("❌ --continue-build 仅用于 --stage genesis", file=sys.stderr)
    sys.exit(1)
```

**实现逻辑**（简化版，完整版见 Q7）：
```python
def resolve_engine(
    cli_engine: Optional[str],
    is_resume: bool,
    runtime_dir: Optional[Path]  # 统一使用 Optional[Path]
) -> str:
    # CLI 参数最高优先（使用 is not None 区分"未指定"和"空字符串"）
    if cli_engine is not None:
        return cli_engine
    
    # 续玩时继承进度引擎
    if is_resume and runtime_dir is not None:
        progress = load_progress(runtime_dir)
        if progress.engine_type:
            return progress.engine_type
    
    # 新开局默认 OS Agent
    return "osagent"
```

#### Q2: 旧入口兼容期策略

**决策**：保留旧入口作为 **薄封装 wrapper**，为期 **2个版本周期**（约1个月）。

**实施**：
1. 旧入口文件保留，内部改为调用新模块
2. 每次调用时打印弃用警告
3. 在 v1.0.0 正式移除

```python
# run_game.py (保留为 wrapper)
import sys
print(
    "\n" + "=" * 60 + "\n"
    "⚠️  run_game.py 已弃用\n"
    "   请使用 python dev.py 替代\n"
    "   此入口将在 v1.0.0 版本移除\n"
    "=" * 60 + "\n",
    file=sys.stderr
)
from cli.dev import main
main(sys.argv[1:])  # 透传参数
```

#### Q3: play.py 的"行动建议"由哪里产出？

**决策**：抽取为独立模块 `utils/action_suggester.py`。

**理由**：
- 当前实现在 `GameEngine.generate_action_suggestions()`
- OS Agent 流程也需要此功能
- 统一抽取为独立模块，两种引擎共用

```python
# utils/action_suggester.py
class ActionSuggester:
    def generate_suggestions(
        self,
        player_name: str,
        location: str,
        present_characters: List[str],
        dialogue_history: List[Dict],
        current_time: str
    ) -> List[str]:
        """生成2个行动建议"""
        ...
```

#### Q4: 旧运行时目录兼容性

**决策**：完全兼容，采用 **向后兼容扩展** 策略。

**保证**：
- `genesis.json` 格式不变
- `plot/current_script.json` 格式不变
- `ws/world_state.json` 格式不变
- `plot/progress.json` **向后兼容扩展**（见下方说明）
- 断点续传逻辑（`load_resume_scene_id`）保持一致

**progress.json 兼容策略**：

```python
# utils/progress_tracker.py

# 默认值常量（确保所有分支一致）
DEFAULT_ENGINE_TYPE = "osagent"
# v1 兼容：默认 False（保守策略，防止旧存档在非安全点切换）
# 只有明确到达边界点（幕间/存档点）时才设为 True
DEFAULT_CAN_SWITCH = False

def load_progress(self, runtime_dir: Path) -> ProgressData:
    """
    加载进度，兼容新旧格式，处理损坏场景。
    
    无论哪种格式，都返回完整的 ProgressData，缺失字段使用默认值。
    """
    progress_file = runtime_dir / "plot" / "progress.json"
    
    if not progress_file.exists():
        # 文件不存在：返回默认进度（使用 DEFAULT_* 常量，can_switch_engine=False）
        return ProgressData()  # 内部使用 DEFAULT_CAN_SWITCH=False
    
    try:
        # 使用 with 语句确保文件句柄关闭（Windows 上 rename 需要）
        with open(progress_file, encoding="utf-8") as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        # JSON 损坏处理
        import sys
        from datetime import datetime
        
        # 使用时间戳避免覆盖之前的备份
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = progress_file.with_suffix(f".corrupted_{timestamp}.json")
        progress_file.rename(backup_path)
        
        # ⚠️ 跨进程限制：重命名后，下一进程只会看到"文件不存在"
        # 这是预期行为：损坏文件已被安全移走，新进程从默认状态开始
        # 若需要区分"不存在"和"已损坏"，需检查 .corrupted_*.json 备份
        
        # 记录到日志文件
        import logging
        logging.error(f"progress.json 损坏并已备份到 {backup_path}: {e}")
        
        print(
            f"\n⚠️  警告：progress.json 损坏 ({e})\n"
            f"   已备份到：{backup_path}\n",
            file=sys.stderr
        )
        
        # 返回带损坏标记的默认进度，让调用方决定是否 fail-fast
        return ProgressData(is_corrupted=True)
    
    # 正常解析流程
    version = data.get("format_version", 1)
    
    # 统一提取字段，缺失时使用默认值
    return ProgressData(
        format_version=version,
        current_scene_id=data.get("current_scene_id", 1),
        next_scene_id=data.get("next_scene_id", 2),
        turn_count=data.get("turn_count", 0),  # v1 无此字段，默认 0
        engine_type=data.get("engine_type", DEFAULT_ENGINE_TYPE),  # v1 无此字段
        updated_at=data.get("updated_at", ""),
        can_switch_engine=data.get("can_switch_engine", DEFAULT_CAN_SWITCH)  # v1 无此字段
    )
```

**调用方处理异常进度**：

```python
# dev.py / play.py 中处理 --resume 的前置检查
def handle_resume(runtime_dir: Path):
    progress_file = runtime_dir / "plot" / "progress.json"
    
    # 1. 检查文件是否存在（防止静默重置到 scene 1）
    if not progress_file.exists():
        print(
            "❌ 无法续玩：progress.json 不存在\n"
            f"   目录：{runtime_dir}\n"
            "   请检查运行时目录是否正确，或使用新游戏开始",
            file=sys.stderr
        )
        sys.exit(1)
    
    # 2. 加载并检查是否损坏
    progress = load_progress(runtime_dir)
    
    if progress.is_corrupted:
        print(
            "❌ 无法续玩：progress.json 已损坏\n"
            "   请手动修复备份文件或删除运行时目录重新开始",
            file=sys.stderr
        )
        sys.exit(1)
    
    # 3. 正常续玩流程...
    return progress
```

**验收条件**：
- 使用新入口可无缝继续旧运行时目录的游戏
- Scene ID、Turn ID 连续，不重置
- 新字段（engine_type 等）缺失时使用默认值
- `load_progress()` 永不返回空值或缺失字段
- `is_corrupted=True` 时调用方正确处理（--resume fail-fast，新游戏用默认）

#### Q5: OS Agent 的 turn_count 从哪里获取？

**决策**：从 `run_scene_loop` 返回值的 `total_turns` 字段获取，并在适配器层累加。

**详细说明**：

1. **来源**：`run_scene_loop()` 返回的 `loop_result["total_turns"]` 表示本次调用执行的回合数
2. **累加策略**：`OSAgentSession` 维护 `_total_turn_count` 累计值，每次调用后累加
3. **持久化策略**（v3.5+）：
   - **回合开始时**：写入 `can_switch_engine=False`（禁止中途切换）
   - **回合结束时**：写入更新后的 `turn_count`，并根据 `success && scene_finished` 设置 `can_switch_engine`
     - ⚠️ **v3.5+ 重要**：`scene_finished` 仅在 `success=True` 时有效，失败回合不应放开切换
   - **显式 save() 调用时**：由 `at_boundary` 参数决定 `can_switch_engine`
4. **恢复**：在 `start()` 或 `resume()` 时从 `load_progress().turn_count` 读取恢复

```python
# OSAgentSession 中的 turn_count 和 can_switch_engine 处理
def process_turn(self, player_input: str) -> TurnResult:
    # 回合开始时禁止切换
    self.progress_tracker.save_progress(..., can_switch_engine=False)
    
    loop_result = self.os_agent.run_scene_loop(...)
    
    # 累加回合数
    turns_this_call = loop_result.get("total_turns", 1)
    self._total_turn_count += turns_this_call
    
    # 检测场景边界（依赖 run_scene_loop 返回约定，见下方）
    # ⚠️ v3.5+：scene_finished 仅在 success=True 时有效
    is_success = loop_result.get("success", False)
    is_scene_boundary = is_success and loop_result.get("scene_finished", False)
    if is_scene_boundary:
        self.current_scene_id = loop_result.get("next_scene_id", self.current_scene_id + 1)
        self._next_scene_id = loop_result.get("following_scene_id", self.current_scene_id + 1)
    
    # 回合结束落盘（仅成功到达边界时允许切换）
    self.progress_tracker.save_progress(
        ...,
        current_scene_id=self.current_scene_id,
        next_scene_id=self._next_scene_id,  # 支持非线性场景
        turn_count=self._total_turn_count,
        can_switch_engine=is_scene_boundary
    )
    
    return TurnResult(..., turn_id=self._total_turn_count, ...)

# run_scene_loop 返回约定（v2.7+）：
# {
#     "success": bool,           # 执行是否成功
#     "total_turns": int,        # 本次执行的回合数
#     "scene_finished": bool,    # 是否到达场景边界（幕间）
#                                # ⚠️ 注意：字段名是 scene_finished，不是 scene_ended
#                                # ⚠️ 仅在 success=True 时有意义，失败时应为 False
#     "next_scene_id": int,      # 边界时：下一场景 ID（可选，默认 current+1）
#                                # ⚠️ 仅在 success=True 且 scene_finished=True 时有效
#     "following_scene_id": int, # 边界时：再下一场景（用于 progress.next_scene_id）
#                                # ⚠️ 仅在 success=True 且 scene_finished=True 时有效
#     ...
# }
#
# 调用方必须先检查 success，失败时不应使用 scene_finished/next_scene_id：
# if loop_result.get("success", False):
#     is_scene_boundary = loop_result.get("scene_finished", False)
#     ...
# else:
#     # 失败：不推进场景，不允许切换引擎
#     is_scene_boundary = False

def save(self, save_name: str, at_boundary: bool = False) -> Path:
    self.progress_tracker.save_progress(
        ...,
        turn_count=self._total_turn_count,
        can_switch_engine=at_boundary,  # 由调用方决定
        ...
    )
```

> **备选方案**：如果 OS Agent 暴露 `turn_count` 属性（如 `self.os_agent.turn_count`），可直接读取。

#### Q6: resume() 的语义与行为规范

**决策**：`resume()` 语义等同于 `start()` 但走断点恢复路径，跳过新游戏开场。

**行为规范**：

| 行为 | start() | resume() |
|------|---------|----------|
| 加载 progress.json | ✓ | ✓ |
| 初始化 Agent/Engine | ✓ | ✓ |
| 生成新游戏开场剧本 | ✓ | ✗ |
| 返回开场文本 | ✓ | ✗ |
| 返回恢复提示 | ✗ | ✓ |

**返回值规范**：

```python
def resume(self) -> str:
    """
    从断点恢复
    
    Returns:
        恢复提示字符串，格式统一为：
        "📂 已从断点恢复\n   场景: 第 X 幕\n   累计回合: Y\n   继续你的冒险..."
    """
```

**调用时机**：
- 用户选择"继续游戏"时：
  1. 先调用 `can_resume()` 检查是否可恢复
  2. 如果返回 True，调用 `resume()` 恢复游戏
  3. 如果返回 False，调用 `get_resume_error()` 获取原因并提示用户
- 新游戏时调用 `start()`
- CLI 主循环应根据用户选择调用正确的方法

**缓存机制（v3.2+）**：
- `_check_resume_state()` 首次调用时缓存结果，后续调用直接返回缓存
- 这确保 `can_resume()` 和 `get_resume_error()` 返回一致的结果
- 原因：`load_progress()` 检测到损坏时会重命名文件，无缓存会导致第二次调用返回"不存在"
- **内部失效点**（v3.4+）：
  - `save()` 方法会自动调用 `invalidate_resume_cache()`
  - `process_turn()` 开始和结束后都会自动调用 `invalidate_resume_cache()`（每次写入 progress.json 后失效）
- **手动失效**：用户修复 progress.json 或返回菜单重新检查前，调用 `invalidate_resume_cache()`

#### Q7: 续玩时引擎选择优先级规则

**问题**：`dev.py` 默认走 OS Agent，但 `progress.json` 存储了 `engine_type`。续玩时应使用哪个引擎？

**决策**：采用 **"进度优先 + 显式覆盖"** 策略。

**优先级规则（从高到低）**：

| 优先级 | 来源 | 说明 |
|--------|------|------|
| 1 | CLI `--engine` 参数 | 用户显式指定，最高优先级 |
| 2 | `progress.json` 的 `engine_type` | 续玩时自动继承上次引擎 |
| 3 | 配置文件 `DevConfig.ENGINE_TYPE` | 默认值（osagent） |

**实现逻辑**：

```python
# cli/engine_resolver.py
# 注意：此函数与 Q1 中的 resolve_engine() 是同一个函数的完整版本

def resolve_engine(
    cli_engine: Optional[str],
    is_resume: bool,
    runtime_dir: Optional[Path],
    default: str = "osagent"
) -> str:
    """
    解析最终使用的引擎类型（统一入口）
    
    Args:
        cli_engine: CLI --engine 参数值（可能为 None）
        is_resume: 是否为续玩模式
        runtime_dir: 运行时目录（续玩时必需）
        default: 默认引擎类型
    
    Returns:
        最终引擎类型: "osagent" 或 "gameengine"
    
    优先级：CLI > progress.json(仅续玩时且未损坏) > default
    """
    # 1. CLI 显式指定优先
    if cli_engine is not None:
        return cli_engine
    
    # 2. 续玩时尝试从 progress.json 读取
    if is_resume and runtime_dir is not None:
        progress_file = runtime_dir / "plot" / "progress.json"
        if progress_file.exists():
            progress = ProgressTracker().load_progress(runtime_dir)
            # 仅从未损坏的进度中继承 engine_type
            if not progress.is_corrupted and progress.engine_type:
                return progress.engine_type
    
    # 3. 新开局或无进度或进度损坏时使用默认值
    return default
```

**警告机制**：

```python
# 当 CLI 指定的引擎与 progress.json 不同时发出警告
# 注意：仅在进度未损坏时进行此检查（损坏时 resolve_engine 已返回默认值）
if (
    not progress.is_corrupted 
    and cli_engine is not None 
    and progress.engine_type 
    and cli_engine != progress.engine_type
):
    print(
        f"⚠️  警告：CLI 指定引擎 ({cli_engine}) 与存档引擎 ({progress.engine_type}) 不同\n"
        f"   继续将使用 {cli_engine}，可能导致状态不一致",
        file=sys.stderr
    )
    if not progress.can_switch_engine:
        print("   ❌ 当前进度不支持引擎切换，操作已中止", file=sys.stderr)
        sys.exit(1)
```

**play.py 行为**：

玩家入口 **固定使用 OS Agent 流程**，不继承 `progress.json` 的 `engine_type`。

**理由**：
- play.py 强制启用 Screen Agent 以提供最佳视觉体验
- GameEngine 不支持 Screen Agent，两者不兼容
- 玩家入口应提供一致的体验，不暴露引擎选择复杂性

**GameEngine 存档兼容性**：
- 如果 `progress.json` 的 `engine_type` 为 `gameengine`，play.py 会显示提示：
  ```
  ⚠️ 此存档由 GameEngine 创建，play.py 将使用 OS Agent 继续。
     进度（scene_id/turn_count）将保留，但引擎专属数据可能不同。
     如需使用 GameEngine 续玩，请运行：python dev.py --engine gameengine
  ```
- 用户确认后，以 OS Agent 模式从 `progress.json` 记录的进度继续

**progress.json 更新策略**：
- play.py 切换引擎前，**必须检查** `progress.can_switch_engine`
- 仅当 `can_switch_engine=true` 时才允许切换（遵守"只在边界切换"规则）
- 切换后更新 `engine_type` 为 `"osagent"`
- 这确保后续 `dev.py --resume` 能正确继承 OS Agent 引擎

```python
# play.py 中的引擎切换处理
if progress.engine_type == "gameengine":
    # 1. 检查是否允许切换（遵守边界规则）
    if not progress.can_switch_engine:
        print(
            "❌ 无法切换引擎：当前进度处于场景/回合中途\n"
            "   请使用 dev.py --engine gameengine 继续，或等待下次存档点",
            file=sys.stderr
        )
        sys.exit(1)
    
    # 2. 用户确认
    if user_confirms_switch():
        # 3. 更新 progress.json 为 OS Agent
        progress_tracker.save_progress(
            runtime_dir=runtime_dir,
            current_scene_id=progress.current_scene_id,
            next_scene_id=progress.next_scene_id,
            turn_count=progress.turn_count,
            engine_type="osagent",  # 更新引擎类型
            can_switch_engine=True  # 保持边界状态
        )
```

#### Q8: 引擎切换时的数据同步规则

**问题**：OS Agent 依赖 `current_script.json`，GameEngine 依赖 `saves/*.json`。切换引擎时如何保证数据一致？

**决策**：采用 **"禁止热切换 + 场景边界检查"** 策略。

**规则**：

1. **can_switch_engine 状态管理**：

   | 时机 | can_switch_engine | 说明 |
   |------|-------------------|------|
   | 初始状态 | `false` | v3.5+ 保守策略，默认禁止切换 |
   | 场景开始 | `false` | 进入场景后禁止切换 |
   | 幕间处理完成 | `true` | OS Agent 完成当前幕后恢复 |
   | save(at_boundary=True) | `true` | 边界保存后恢复 |
   | save(at_boundary=False) | `false` | 中途保存（如 /quit）保持禁止 |
   | 回合中途 | `false` | 有未保存状态时禁止 |

   **关键实现**（所有状态变更必须持久化到 progress.json）：
   ```python
   # === 设置为 false 的时机（必须持久化，防止重启后状态丢失）===
   
   # OS Agent 场景开始时
   def on_scene_start(self):
       self.progress_tracker.save_progress(..., can_switch_engine=False)
   
   # GameEngine 每回合开始时（必须持久化！）
   def process_turn(self, player_input: str) -> TurnResult:
       # 立即持久化到 progress.json，防止重启后允许不安全切换
       self.progress_tracker.save_progress(
           runtime_dir=self.runtime_dir,
           current_scene_id=self._scene_id,
           next_scene_id=self._next_scene_id,  # 保留已维护的值，不回退
           turn_count=self._turn_count,
           engine_type="gameengine",
           can_switch_engine=False  # 回合中禁止切换
       )
       ...
   
   # === 设置为 true 的时机 ===
   
   # OS Agent 回合结束时检测 loop_result.scene_finished（v4.0+ 修正字段名）
   # ⚠️ v3.5+：scene_finished 仅在 success=True 时有效
   def process_turn(self, player_input: str) -> TurnResult:
       loop_result = self.os_agent.run_scene_loop(...)
       is_success = loop_result.get("success", False)
       is_scene_boundary = is_success and loop_result.get("scene_finished", False)
       self.progress_tracker.save_progress(..., can_switch_engine=is_scene_boundary)
   
   # save() 调用时（由 at_boundary 参数决定）
   def save(self, save_name: str, at_boundary: bool = False) -> Path:
       ...
       self.progress_tracker.save_progress(..., can_switch_engine=at_boundary)
   ```
   
   > **重要**：
   > - 所有 `can_switch_engine` 状态变更必须立即写入 progress.json
   > - 边界检测**统一**依赖 `loop_result.scene_finished`（v4.0+ 修正字段名，废弃独立 `on_scene_end()` 方法）
   > - `at_boundary=True`（显式 save）：幕间自动保存、存档点 → 允许切换
   > - `at_boundary=False`（显式 save）：用户 /quit、中途退出 → 禁止切换

2. **场景边界检查**：仅在 `can_switch_engine=true` 时允许切换：
   - OS Agent：完成当前幕（幕间处理后）
   - GameEngine：执行 `save()` 后

3. **数据迁移规则**：切换时不迁移引擎专属数据，仅依赖 `progress.json` 的通用字段：

| 字段 | OS Agent | GameEngine | 切换时行为 |
|------|----------|------------|-----------|
| `current_scene_id` | ✓ | ✓ | 保持（两边共用） |
| `turn_count` | ✓ | ✓ | 保持（两边共用） |
| `current_script.json` | ✓ | ✗ | OS→GE 时忽略 |
| `saves/*.json` | ✗ | ✓ | GE→OS 时忽略 |
| `world_state.json` | ✓ | ✓ | 保持（两边共用） |

**切换行为**：

```python
# cli/engine_switcher.py

def can_switch_engine(runtime_dir: Path) -> Tuple[bool, str]:
    """
    检查是否可以切换引擎
    
    Returns:
        (可以切换, 原因说明)
    """
    # 先检查进度文件是否存在
    progress_file = runtime_dir / "plot" / "progress.json"
    if not progress_file.exists():
        return False, "progress.json 不存在，无法切换引擎"
    
    progress = ProgressTracker().load_progress(runtime_dir)
    
    # 检查进度是否损坏
    if progress.is_corrupted:
        return False, "progress.json 已损坏，无法切换引擎"
    
    if not progress.can_switch_engine:
        return False, "当前进度处于场景/回合中途，不支持切换"
    
    return True, "可以安全切换"

def switch_engine(runtime_dir: Path, target_engine: str) -> None:
    """
    切换引擎（仅更新 progress.json，不迁移数据）
    
    Raises:
        RuntimeError: 如果当前进度不支持切换
    """
    can_switch, reason = can_switch_engine(runtime_dir)
    if not can_switch:
        raise RuntimeError(f"无法切换引擎：{reason}")
    
    # 更新 progress.json 的 engine_type（显式传入所有参数，不依赖默认值）
    progress = ProgressTracker().load_progress(runtime_dir)
    ProgressTracker().save_progress(
        runtime_dir=runtime_dir,
        current_scene_id=progress.current_scene_id,
        next_scene_id=progress.next_scene_id,
        turn_count=progress.turn_count,
        engine_type=target_engine,
        can_switch_engine=True  # 切换完成后允许再次切换
    )
    
    print(f"✅ 引擎已切换为 {target_engine}")
    print(f"   注意：切换后将从场景 {progress.current_scene_id}、回合 {progress.turn_count} 继续")
```

**用户提示**：

```
⚠️  引擎切换注意事项：
   - 切换不会迁移引擎专属数据（如 OS Agent 的剧本、GameEngine 的存档）
   - 新引擎将从 progress.json 记录的场景和回合继续
   - 如需完整体验，建议在场景边界切换或开始新游戏
```

#### Q9: Screen Agent 开关与 GameEngine 兼容性

**问题**：`dev.py` 提供 `--screen-agent` 开关，但 GameEngine 路径不支持 Screen Agent。应如何处理？

**决策**：采用 **"警告 + 忽略"** 策略。

**规则**：

| 引擎 | Screen Agent 开关 | 行为 |
|------|-------------------|------|
| OS Agent | `--screen-agent` | ✅ 正常启用 |
| OS Agent | `--no-screen-agent` | ✅ 禁用 Screen Agent |
| GameEngine | `--screen-agent` | ⚠️ 警告并忽略 |
| GameEngine | `--no-screen-agent` | ✅ 无操作（本就不支持） |

**实现逻辑**：

```python
# cli/dev.py

def validate_engine_options(engine_type: str, config: DevConfig) -> DevConfig:
    """
    验证引擎与选项的兼容性，返回调整后的配置
    """
    if engine_type == "gameengine" and config.ENABLE_SCREEN_AGENT:
        print(
            "⚠️  警告：Screen Agent 仅支持 OS Agent 流程，"
            "GameEngine 模式下该选项将被忽略",
            file=sys.stderr
        )
        # 返回调整后的配置，禁用 Screen Agent
        return DevConfig(**{
            **asdict(config),
            'ENABLE_SCREEN_AGENT': False
        })
    return config
```

**验收标准**：
- GameEngine + `--screen-agent`：显示警告，正常运行（无 Screen Agent 渲染）
- GameEngine + 默认：无警告，正常运行
- OS Agent + 任意组合：按开关执行

---

## 3. play.py 详细规划

### 3.1 功能模块

```
┌─────────────────────────────────────────────────────────────┐
│                     play.py 功能架构                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌─────────────────┐    ┌─────────────────┐                │
│   │   主菜单模块     │    │   世界管理模块   │                │
│   │                 │    │                 │                │
│   │ • 开始游戏      │───→│ • 显示可用世界   │                │
│   │ • 继续游戏      │    │ • 世界信息预览   │                │
│   │ • 退出          │    │ • 存档列表      │                │
│   └─────────────────┘    └─────────────────┘                │
│            │                      │                          │
│            ▼                      ▼                          │
│   ┌─────────────────────────────────────────┐               │
│   │              游戏运行模块                 │               │
│   │                                         │               │
│   │  • OS Agent 完整流程                     │               │
│   │  • Screen Agent 荧幕层渲染               │               │
│   │  • 场景演绎循环                          │               │
│   │  • 幕间处理与进度保存                    │               │
│   │  • 行动建议生成                          │               │
│   └─────────────────────────────────────────┘               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 界面设计

#### 3.2.1 启动画面

```
╔══════════════════════════════════════════════════════════════╗
║                                                              ║
║           🎭  I N F I N I T E   S T O R Y                   ║
║                    无 限 故 事 机                            ║
║                                                              ║
║           ─────────────────────────────────                 ║
║           基于AI的生成式互动叙事游戏                          ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝

  请选择：

    [1] ▶️  开始新故事
    [2] 📂 继续已有故事
    [0] 👋 退出

  > _
```

#### 3.2.2 世界选择界面

```
╭──────────────────────────────────────────────────────────────╮
│  📚 可用的故事世界                                            │
╰──────────────────────────────────────────────────────────────╯

  [1] 🌾 白鹿原
      类型: 年代史诗 | 角色: 46人
      "渭河平原上的白鹿村，两个家族的恩怨..."

  [2] 🌃 都市迷局 (江城市)
      类型: 都市悬疑 | 角色: 9人
      "灯红酒绿的江城市，一场阴谋正在酝酿..."

  [0] ← 返回主菜单

  请选择世界 > _
```

#### 3.2.3 存档选择界面

```
╭──────────────────────────────────────────────────────────────╮
│  📂 白鹿原 - 存档列表                                         │
╰──────────────────────────────────────────────────────────────╯

  [0] 🆕 开始新游戏

  ─────────────────────────────────────────────────────────────
  继续已有存档：

  [1] 白鹿原_20251222_143908
      进度: 第3幕 | 时间: 2025-12-22 14:39

  [2] 白鹿原_20251219_112721
      进度: 第4幕 | 时间: 2025-12-19 11:27

  请选择 > _
```

#### 3.2.4 角色创建界面

```
╭──────────────────────────────────────────────────────────────╮
│  📝 创建你的角色                                              │
╰──────────────────────────────────────────────────────────────╯

  你即将进入《白鹿原》的世界。
  在这里，你将以一个新角色的身份体验这个故事。

  ─────────────────────────────────────────────────────────────

  角色名字 (回车使用默认名"旅人") > _

  性别 (可选，回车跳过) > _

  一句话描述你的外貌 (可选) > _
```

#### 3.2.5 游戏界面 - 场景渲染

```
════════════════════════════════════════════════════════════════
  🎬 第 3 幕：村口古槐树下
════════════════════════════════════════════════════════════════

[环境] 清晨的薄雾还未散尽，古槐树下已有几个早起的村民聚在一起。
       远处传来几声狗吠，打破了黎明的寂静。

──────────────────────────────────────────────────────────────

[白嘉轩]: (神色凝重)
  "这事儿蹊跷得很，昨夜狗叫得那样凶，偏偏又突然没了动静。"

[鹿三]: (低声回应)
  "族长，我在马号守了一宿，确实瞧见个影子往西头烂窑那边去了。"

──────────────────────────────────────────────────────────────

💡 行动建议：
  [1] 询问鹿三更多关于那个影子的细节
  [2] 提议去西头烂窑那边查看

👤 你的行动 > _
```

#### 3.2.6 游戏界面 - 幕间过渡

```

──────────────────────────────────────────────────────────────
  🔄 幕间过渡
──────────────────────────────────────────────────────────────

  第3幕演绎完成。

  📊 本幕回顾：
     • 对话轮数: 8
     • 关键事件: 发现可疑踪迹

  ⏳ 正在推演下一幕剧情...

──────────────────────────────────────────────────────────────

  继续下一幕? [Y/n] > _
```

### 3.3 日志策略（详细）

**玩家入口的日志处理架构**：

```
┌─────────────────────────────────────────────────────────────┐
│                       日志处理流程                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Agent 日志                                                 │
│      │                                                       │
│      ▼                                                       │
│   ┌──────────────────┐                                      │
│   │  PlayerLogFilter │  ← 拦截所有 Agent 日志               │
│   └──────────────────┘                                      │
│      │           │                                          │
│      ▼           ▼                                          │
│   终端输出    文件写入                                       │
│   (静默)     (完整保留)                                      │
│              logs/game_YYYYMMDD_HHMMSS.log                  │
│                                                              │
│   异常处理                                                   │
│      │                                                       │
│      ▼                                                       │
│   ┌──────────────────┐                                      │
│   │ ExceptionHandler │                                      │
│   └──────────────────┘                                      │
│      │           │                                          │
│      ▼           ▼                                          │
│   友好提示    完整堆栈                                       │
│   (终端)     (日志文件)                                      │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**1. 日志文件写入规则**：

```python
# utils/player_log_filter.py
import logging
from pathlib import Path
from datetime import datetime

# 定义自定义日志级别 GAME（介于 INFO(20) 和 WARNING(30) 之间）
GAME_LEVEL = 25
logging.addLevelName(GAME_LEVEL, "GAME")

def game(self, message, *args, **kwargs):
    """自定义 logger.game() 方法"""
    if self.isEnabledFor(GAME_LEVEL):
        self._log(GAME_LEVEL, message, args, **kwargs)

logging.Logger.game = game

class PlayerLogFilter:
    def __init__(self, log_dir: Path):
        # 确保 logs/ 目录存在
        log_dir.mkdir(parents=True, exist_ok=True)
        
        self.log_file = log_dir / f"game_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"
        self.file_handler = logging.FileHandler(self.log_file, encoding='utf-8')
        self.file_handler.setLevel(logging.DEBUG)  # 文件记录所有级别
        self.file_handler.setFormatter(
            logging.Formatter('[%(asctime)s] [%(name)s] [%(levelname)s] %(message)s')
        )
        
    def setup_root_logger(self):
        """配置根日志器"""
        root = logging.getLogger()
        root.setLevel(logging.DEBUG)
        
        # 添加文件处理器（记录所有）
        root.addHandler(self.file_handler)
        
        # 添加终端处理器（仅 GAME 级别）
        terminal_handler = logging.StreamHandler()
        terminal_handler.setLevel(GAME_LEVEL)
        terminal_handler.addFilter(lambda r: r.levelno == GAME_LEVEL)
        root.addHandler(terminal_handler)
        
    def filter_for_terminal(self, record: logging.LogRecord) -> bool:
        """终端只显示 GAME 级别"""
        return record.levelno == GAME_LEVEL
```

**2. 异常转友好提示映射**：

```python
# utils/exception_handler.py
FRIENDLY_MESSAGES = {
    "APIConnectionError": "网络连接失败，请检查网络后重试",
    "RateLimitError": "请求过于频繁，请稍后再试",
    "JSONDecodeError": "数据解析异常，游戏将使用备用方案继续",
    "TimeoutError": "服务响应超时，正在重试...",
    "FileNotFoundError": "游戏数据缺失，请确认世界已正确构建",
}

def handle_exception(e: Exception, context: str = "") -> str:
    """返回友好提示，同时记录完整堆栈到日志"""
    error_type = type(e).__name__
    friendly_msg = FRIENDLY_MESSAGES.get(error_type, f"发生意外错误: {str(e)[:50]}")
    
    # 完整堆栈写入日志
    logger.error(f"[{context}] {error_type}: {e}", exc_info=True)
    
    return f"❌ {friendly_msg}\n   (详细信息已记录到 logs/ 目录)"
```

**3. 玩家可见信息级别**：

| 信息类型 | 终端显示 | 日志文件 | 示例 |
|----------|----------|----------|------|
| 场景描述 | ✅ | ✅ | Screen Agent 渲染输出 |
| NPC对话 | ✅ | ✅ | 角色台词和动作 |
| 系统提示 | ✅ | ✅ | "游戏已保存"、"加载中..." |
| 友好错误 | ✅ | ✅ | "网络连接失败" |
| Agent调用 | ❌ | ✅ | "[Plot] 生成场景剧本" |
| 调试信息 | ❌ | ✅ | 参数值、中间状态 |
| 完整堆栈 | ❌ | ✅ | Exception traceback |

**4. 加载进度显示**：

```
⏳ 正在加载游戏世界...
   ████████████████████████░░░░░░  80%
✅ 加载完成！
```

### 3.4 需要抽取的公共模块（迁移前置条件）

> ⚠️ **重要**：先抽取公共模块，再实现新入口。避免直接从旧入口导入导致的依赖断裂。

**迁移顺序**：
```
阶段0: 抽取公共模块 (cli/, utils/新增)
    ↓
阶段1: 实现 play.py (依赖公共模块)
    ↓
阶段2: 实现 dev.py (依赖公共模块)
    ↓
阶段3: 旧入口改为 wrapper (调用新入口)
    ↓
阶段4: 测试验收
    ↓
阶段5: 弃用期结束后删除旧入口
```

**公共模块抽取清单**：

```python
# ============================================================
# cli/world_manager.py - 世界管理（从 play_game.py, run_world_builder.py 抽取）
# ============================================================
class WorldManager:
    def list_available_worlds(self) -> List[WorldInfo]: ...
    def get_world_info(self, world_name: str) -> WorldInfo: ...
    def list_runtimes(self, world_name: str) -> List[RuntimeInfo]: ...
    def get_runtime_info(self, runtime_dir: Path) -> RuntimeInfo: ...

# ============================================================
# cli/game_session.py - 游戏会话（统一运行契约，见第5节）
# ============================================================
class GameSession:
    def __init__(self, runtime_dir: Path, engine_type: str = "osagent"): ...
    def start(self) -> str: ...           # 返回开场文本
    def process_turn(self, player_input: str) -> TurnResult: ...
    def save(self, save_name: str, at_boundary: bool = False) -> Path: ...
    def can_resume(self) -> bool: ...     # 是否可以断点续传
    def get_resume_error(self) -> Optional[str]: ...  # 无法恢复的原因
    def resume(self) -> str: ...          # 从断点恢复
    def invalidate_resume_cache(self) -> None: ...  # 使恢复状态缓存失效
    def get_status(self) -> SessionStatus: ...

# ============================================================
# cli/player_profile.py - 玩家角色（从 play_game.py, main.py 抽取）
# ============================================================
def prompt_player_profile() -> PlayerProfile: ...
def create_player_character(world_dir: Path, profile: PlayerProfile) -> Path: ...

# ============================================================
# utils/progress_tracker.py - 断点续传（从 main.py 抽取）
# ============================================================
@dataclass
class ProgressData:
    """进度数据（v2格式，向后兼容）"""
    format_version: int = 2
    current_scene_id: int = 1
    next_scene_id: int = 2
    turn_count: int = 0
    engine_type: str = DEFAULT_ENGINE_TYPE  # "osagent"
    updated_at: str = ""
    can_switch_engine: bool = DEFAULT_CAN_SWITCH  # v3.5+: False（保守策略）
    is_corrupted: bool = False  # 标记 progress.json 是否损坏

class ProgressTracker:
    def load_resume_scene_id(self, runtime_dir: Path) -> int:
        """
        获取恢复场景ID（便捷方法）
        
        注意：
        - 内部调用 load_progress() 以复用 v2 默认值补齐逻辑
        - 如果 is_corrupted=True，抛出异常而非返回默认值
        
        Raises:
            RuntimeError: 如果 progress.json 损坏
        """
        progress = self.load_progress(runtime_dir)
        if progress.is_corrupted:
            raise RuntimeError("progress.json 已损坏，无法获取恢复场景ID")
        return progress.current_scene_id
    
    def load_progress(self, runtime_dir: Path) -> ProgressData:
        """加载完整进度数据（自动补齐默认值）"""
        ...
    
    def save_progress(
        self,
        runtime_dir: Path,
        current_scene_id: int,
        next_scene_id: int,
        turn_count: int = 0,
        engine_type: str = DEFAULT_ENGINE_TYPE,
        can_switch_engine: bool = DEFAULT_CAN_SWITCH  # v3.6+: 默认 False（保守策略）
    ) -> None:
        """
        保存进度（v2格式）
        
        Args:
            runtime_dir: 运行时目录
            current_scene_id: 当前场景 ID
            next_scene_id: 下一场景 ID
            turn_count: 累计回合数
            engine_type: 引擎类型 ("osagent" | "gameengine")
            can_switch_engine: 是否允许切换引擎（场景中途应为 False）
        
        以下字段由函数内部自动补齐：
        - format_version: 固定为 2
        - updated_at: 自动填充当前时间戳
        
        示例实现：
            data = {
                "format_version": 2,
                "current_scene_id": current_scene_id,
                "next_scene_id": next_scene_id,
                "turn_count": turn_count,
                "engine_type": engine_type,
                "updated_at": datetime.now().isoformat(),
                "can_switch_engine": can_switch_engine  # 使用传入值
            }
            (runtime_dir / "plot" / "progress.json").write_text(
                json.dumps(data, ensure_ascii=False, indent=2)
            )
        """
        ...

# ============================================================
# utils/action_suggester.py - 行动建议（从 game_engine.py 抽取）
# ============================================================
class ActionSuggester:
    def generate_suggestions(
        self,
        player_name: str,
        location: str,
        present_characters: List[str],
        dialogue_history: List[Dict],
        current_time: str
    ) -> List[str]: ...

# ============================================================
# utils/screen_renderer.py - 终端渲染（从 main.py 抽取 screen_callback 逻辑）
# ============================================================
class ScreenRenderer:
    def render_scene_header(self, scene_id: int, location: str, desc: str): ...
    def render_dialogue(self, speaker: str, content: str, action: str, is_player: bool): ...
    def render_scene_end(self, scene_id: int): ...
```

**play.py 最终依赖关系**：

```python
# play.py 干净的导入（不依赖旧入口）
from cli.world_manager import WorldManager
from cli.game_session import GameSession
from cli.player_profile import prompt_player_profile
from utils.progress_tracker import ProgressTracker
from utils.action_suggester import ActionSuggester
from utils.screen_renderer import ScreenRenderer
from utils.player_log_filter import PlayerLogFilter
from utils.exception_handler import handle_exception
```

---

## 4. dev.py 详细规划

### 4.1 功能模块

```
┌─────────────────────────────────────────────────────────────┐
│                     dev.py 功能架构                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌─────────────────────────────────────────────────────┐   │
│   │                    命令行参数层                       │   │
│   │                                                     │   │
│   │  --stage [genesis|illuminati|game|all]              │   │
│   │  --world <世界名>                                    │   │
│   │  --novel <小说文件>                                  │   │
│   │  --runtime <运行时目录>                              │   │
│   │  --parallel / --no-parallel                         │   │
│   │  --verbose / --quiet                                │   │
│   │  --auto-test                                        │   │
│   │  --max-turns <回合数>                                │   │
│   │  --enable-vibe / --disable-vibe                     │   │
│   │  --enable-logic / --disable-logic                   │   │
│   └─────────────────────────────────────────────────────┘   │
│                           │                                  │
│            ┌──────────────┼──────────────┐                  │
│            ▼              ▼              ▼                  │
│   ┌────────────┐  ┌────────────┐  ┌────────────┐           │
│   │ 创世组模块  │  │ 光明会模块  │  │ 游戏运行   │           │
│   │            │  │            │  │            │           │
│   │ • 并行化   │  │ • WS初始化 │  │ • 完整日志 │           │
│   │ • 断点续传 │  │ • Plot生成 │  │ • 状态快照 │           │
│   │ • 进度显示 │  │ • Vibe生成 │  │ • 性能计时 │           │
│   └────────────┘  └────────────┘  └────────────┘           │
│                                                              │
│   ┌─────────────────────────────────────────────────────┐   │
│   │                    调试工具层                         │   │
│   │                                                     │   │
│   │  • Agent状态查看                                     │   │
│   │  • 世界数据检查                                      │   │
│   │  • 运行时目录管理                                    │   │
│   │  • 日志级别控制                                      │   │
│   └─────────────────────────────────────────────────────┘   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 命令行参数设计

```bash
# 完整流程（默认）
python dev.py

# 仅运行创世组
python dev.py --stage genesis --novel 白鹿原.txt

# 仅运行光明会初始化
python dev.py --stage illuminati --world 白鹿原

# 仅运行游戏
python dev.py --stage game --runtime data/runtime/白鹿原_20251222_143908

# 并行化控制
python dev.py --stage genesis --novel 白鹿原.txt --parallel --concurrency 5

# 创世组断点续传（--continue-build 带世界名参数）
python dev.py --stage genesis --continue-build 白鹿原

# 调试模式
python dev.py --verbose --enable-vibe --enable-logic

# 自动测试模式
python dev.py --auto-test --max-turns 10

# 查看世界列表
python dev.py --list-worlds

# 查看运行时列表
python dev.py --list-runtimes --world 白鹿原

# 清理运行时数据
python dev.py --cleanup-runtimes --world 白鹿原 --keep 3
```

### 4.3 界面设计

#### 4.3.1 启动界面

```
════════════════════════════════════════════════════════════════════════════════
  🛠️  Infinite Story - 开发者控制台
════════════════════════════════════════════════════════════════════════════════

  版本: v0.9.0
  LLM: OpenRouter (google/gemini-3-flash-preview)
  日志级别: DEBUG
  并行模式: ON (并发数: 5)

────────────────────────────────────────────────────────────────────────────────

  📋 可用操作:

    [1] 🏗️  创世组 - 从小说构建世界
    [2] ⚡ 光明会 - 初始化游戏世界
    [3] 🎮 游戏运行 - 启动游戏流程
    [4] 🔄 完整流程 - 从小说到游戏
    [5] 📊 状态查看 - 查看世界/运行时状态
    [6] 🧹 清理工具 - 清理运行时数据
    [0] 👋 退出

  请选择 > _
```

#### 4.3.2 创世组运行界面

```
════════════════════════════════════════════════════════════════════════════════
  🏗️  创世组 - 世界构建
════════════════════════════════════════════════════════════════════════════════

  📖 小说: 白鹿原.txt (1,234,567 字)
  📁 输出: data/worlds/白鹿原/

────────────────────────────────────────────────────────────────────────────────

  [2025-12-29 10:30:15] [Genesis] 📍 阶段1+2 并行启动
  [2025-12-29 10:30:15] [Genesis] 🎭 [并行] 启动阶段1：角色普查 (大中正)
  [2025-12-29 10:30:15] [Genesis] 🌍 [并行] 启动阶段2：世界观提取 (Demiurge)
  [2025-12-29 10:30:45] [Genesis] ✅ [并行] 阶段1完成，识别到 46 个角色
  [2025-12-29 10:30:52] [Genesis] ✅ [并行] 阶段2完成
  [2025-12-29 10:30:52] [Genesis] 📊 阶段1+2并行完成，总耗时: 37.2s

────────────────────────────────────────────────────────────────────────────────

  [2025-12-29 10:30:52] [Genesis] 📍 阶段3：角色档案生成 (许劭) - 并行模式 (并发数: 5)
  [2025-12-29 10:30:52] [Genesis] 📋 待处理角色: 46 个

  进度: ████████████████████░░░░░░░░░░  20/46 (43%)
  当前: npc_021 (白孝文)

  [2025-12-29 10:31:05] ✅ npc_001 (白嘉轩) 档案创建完成
  [2025-12-29 10:31:08] ✅ npc_002 (鹿子霖) 档案创建完成
  [2025-12-29 10:31:12] ✅ npc_003 (白孝武) 档案创建完成
  ...
```

#### 4.3.3 游戏运行界面（详细模式）

```
════════════════════════════════════════════════════════════════════════════════
  🎮 游戏运行 - 详细模式
════════════════════════════════════════════════════════════════════════════════

  📁 运行时: data/runtime/白鹿原_20251222_143908
  🎬 当前场景: 第3幕
  ⏱️ 游戏时间: 清晨

────────────────────────────────────────────────────────────────────────────────

  [10:35:22] [OS] 📜 拆分剧本...
  [10:35:22] [OS]    ✅ 剧本拆分完成: 3 个任务卡
  [10:35:22] [OS] 🎭 初始化出场角色...
  [10:35:22] [OS]    ℹ️ 无新角色需要初始化
  [10:35:22] [OS] 🎬 开始第 3 幕演绎...

────────────────────────────────────────────────────────────────────────────────

  [10:35:23] [Plot] 📍 生成场景剧本
  [10:35:23] [Plot]    - 在场角色: 白嘉轩, 鹿三, 仙草
  [10:35:23] [Plot]    - 当前幕目标: 发现异常踪迹
  [10:35:23] [Plot]    - 紧迫度: 0.65

  [10:35:25] [WS] 📍 更新世界状态
  [10:35:25] [WS]    - 时间流逝: 10分钟
  [10:35:25] [WS]    - NPC状态更新: 3 个

  [10:35:26] [NPC] 🎭 白嘉轩 响应中...
  [10:35:27] [NPC] 🎭 鹿三 响应中...
  [10:35:28] [NPC] ✅ 场景演绎完成 (2.3s)

  [10:35:28] [Screen] 🎨 执行视觉翻译...
  [10:35:30] [Screen] ✅ 视觉翻译完成
  [10:35:30] [Screen] 💾 视觉数据已保存

════════════════════════════════════════════════════════════════════════════════
  🎬 第 3 幕：村口古槐树下
════════════════════════════════════════════════════════════════════════════════

  [白嘉轩]: "这事儿蹊跷得很，昨夜狗叫得那样凶..."

────────────────────────────────────────────────────────────────────────────────

  👤 你的行动 (/help 查看命令) > _
```

#### 4.3.4 状态查看界面

```
════════════════════════════════════════════════════════════════════════════════
  📊 状态查看
════════════════════════════════════════════════════════════════════════════════

  🌍 已创建的世界
  ────────────────────────────────────────────────────────────────────────────

  序号  世界名称              阶段1    阶段2    角色数   状态
  ────────────────────────────────────────────────────────────────────────────
  1     白鹿原                ✅       ✅       46       ✅ 完成
  2     都市迷局 (江城市)     ✅       ✅       9        ✅ 完成
  3     三体 (地球往事)       ✅       ✅       12       ⚠️ 3个失败

  ────────────────────────────────────────────────────────────────────────────

  📁 运行时目录 (白鹿原)
  ────────────────────────────────────────────────────────────────────────────

  序号  目录名                           创建时间              进度
  ────────────────────────────────────────────────────────────────────────────
  1     白鹿原_20251222_143908           2025-12-22 14:39      第4幕
  2     白鹿原_20251219_112721           2025-12-19 11:27      第4幕

  ────────────────────────────────────────────────────────────────────────────

  [1-2] 查看运行时详情  [B] 返回  [0] 退出

  请选择 > _
```

### 4.4 需要抽取的公共模块（迁移前置条件）

> ⚠️ **重要**：与 play.py 共用公共模块，额外抽取开发者专用模块。

**开发者专用模块抽取清单**：

```python
# ============================================================
# cli/genesis_runner.py - 创世组运行器（从 run_world_builder.py 抽取）
# ============================================================
class GenesisRunner:
    def __init__(self, novel_filename: str, world_name: Optional[str] = None):
        self.checkpoint = Checkpoint()
        ...
    
    def run_stage1(self, novel_text: str) -> List[Dict]: ...      # 角色普查
    def run_stage2(self, novel_text: str) -> Dict: ...            # 世界设定
    async def run_stage3_parallel(self, ...) -> Dict: ...         # 角色档案（并行）
    def run_all(self) -> Path: ...                                 # 完整流程
    
    def get_checkpoint(self) -> Checkpoint: ...
    def resume_from_checkpoint(self) -> Path: ...

# ============================================================
# cli/illuminati_runner.py - 光明会运行器（从 initial_Illuminati.py 抽取）
# ============================================================
class IlluminatiRunner:
    def __init__(self, world_name: str, player_profile: Optional[Dict] = None): ...
    def run(self) -> Path: ...                                     # 返回 runtime_dir

# ============================================================
# utils/concurrency.py - 并发控制（从 run_world_builder.py 抽取，公开 API）
# ============================================================
class LLMConcurrencyManager:
    """LLM 并发控制管理器（线程安全）"""
    
    def __init__(self, max_concurrency: int = 5):
        self._concurrency = max_concurrency
        self._semaphores: WeakKeyDictionary = WeakKeyDictionary()
    
    def get_semaphore(self) -> asyncio.Semaphore:
        """获取与当前事件循环绑定的 Semaphore"""
        ...
    
    def set_concurrency(self, value: int):
        """动态调整并发数"""
        ...

# 全局单例
llm_concurrency = LLMConcurrencyManager()

# ============================================================
# cli/checkpoint.py - 检查点管理（从 run_world_builder.py 抽取）
# ============================================================
@dataclass
class Checkpoint:
    stage1_done: bool = False
    stage2_done: bool = False
    stage3_done: bool = False
    stage3_completed_characters: List[str] = field(default_factory=list)
    stage3_failed_characters: List[str] = field(default_factory=list)
    last_updated: str = ""
    novel_filename: str = ""
    world_name: str = ""
    
    def to_dict(self) -> Dict: ...
    @classmethod
    def from_dict(cls, data: Dict) -> "Checkpoint": ...
    @classmethod
    def load(cls, path: Path) -> "Checkpoint": ...
    def save(self, path: Path): ...

# ============================================================
# cli/dev_tools.py - 开发者工具（新建）
# ============================================================
class DevTools:
    def list_worlds_detailed(self) -> List[Dict]: ...            # 带进度信息
    def list_novels(self) -> List[Path]: ...
    def cleanup_runtimes(self, world_name: str, keep: int = 3): ...
    def inspect_runtime(self, runtime_dir: Path) -> Dict: ...
    def validate_world_data(self, world_dir: Path) -> List[str]: ...  # 返回问题列表
```

**dev.py 最终依赖关系**：

```python
# dev.py 干净的导入（不依赖旧入口）
from cli.world_manager import WorldManager
from cli.game_session import GameSession
from cli.genesis_runner import GenesisRunner
from cli.illuminati_runner import IlluminatiRunner
from cli.checkpoint import Checkpoint
from cli.dev_tools import DevTools
from utils.concurrency import llm_concurrency
from utils.progress_tracker import ProgressTracker
from utils.screen_renderer import ScreenRenderer
```

---

## 5. 统一运行契约（GameSession 接口）

> 解决审阅意见：OS Agent 与 GameEngine 产出的运行时数据/断点续传规则可能分叉

### 5.1 问题分析

当前两种游戏引擎的差异：

| 维度 | OS Agent 流程 (main.py) | GameEngine (play_game.py) |
|------|-------------------------|---------------------------|
| 场景管理 | scene_id 驱动 | turn_count 驱动 |
| 断点续传 | progress.json | StateManager (SQLite) |
| 状态文件 | ws/world_state.json | 内存 + saves/*.json |
| NPC响应 | SceneNarrator | NPCManager |
| 输出渲染 | Screen Agent | _render_output() |

**问题**：两套引擎产出的运行时数据格式不一致，切换引擎时可能丢失进度。

### 5.2 统一契约设计

```python
# cli/game_session.py

from abc import ABC, abstractmethod
from dataclasses import dataclass
from pathlib import Path
from typing import List, Dict, Any, Optional

@dataclass
class TurnResult:
    """回合结果（统一格式）"""
    success: bool
    text: str                               # 渲染后的输出文本
    error: Optional[str] = None
    scene_id: int = 0
    turn_id: int = 0
    npc_reactions: List[Dict] = None        # 标准化的 NPC 反应
    world_state_delta: Optional[Dict] = None

@dataclass
class SessionStatus:
    """会话状态（统一格式）"""
    scene_id: int
    turn_id: int
    location: str
    current_time: str
    present_characters: List[str]
    can_continue: bool

class GameSession(ABC):
    """游戏会话抽象基类（统一运行契约）"""
    
    @abstractmethod
    def start(self) -> str:
        """开始游戏，返回开场文本"""
        pass
    
    @abstractmethod
    def process_turn(self, player_input: str) -> TurnResult:
        """处理玩家输入，返回回合结果"""
        pass
    
    @abstractmethod
    def save(self, save_name: str, at_boundary: bool = False) -> Path:
        """
        保存游戏，返回存档路径
        
        Args:
            save_name: 存档名称
            at_boundary: 是否在边界点（幕间/存档点），影响 can_switch_engine 状态
        """
        pass
    
    @abstractmethod
    def get_status(self) -> SessionStatus:
        """获取当前会话状态"""
        pass
    
    @abstractmethod
    def get_action_suggestions(self) -> List[str]:
        """获取行动建议"""
        pass
    
    @abstractmethod
    def can_resume(self) -> bool:
        """是否可以断点续传"""
        pass
    
    @abstractmethod
    def get_resume_error(self) -> Optional[str]:
        """
        获取无法恢复的原因
        
        注意：应在 can_resume()==False 后立即调用，避免中间状态变化
        实现建议：与 can_resume() 共享内部检查逻辑（如 _check_resume_state）
        
        Returns:
            None: 如果可以恢复
            str: 错误原因（如"progress.json 不存在"或"progress.json 已损坏"）
        """
        pass
    
    @abstractmethod
    def invalidate_resume_cache(self) -> None:
        """
        使恢复状态缓存失效
        
        调用时机：
        - progress.json 被外部修改后（如用户手动修复）
        - 返回菜单重新检查前
        - save() 内部会自动调用
        """
        pass
    
    @abstractmethod
    def resume(self) -> str:
        """从断点恢复，返回恢复提示"""
        pass
```

### 5.3 两种引擎的适配器

```python
# cli/osagent_session.py

class OSAgentSession(GameSession):
    """OS Agent 流程的会话适配器（示例为核心方法节选）"""
    
    def __init__(self, runtime_dir: Path, world_dir: Path):
        self.runtime_dir = runtime_dir
        self.world_dir = world_dir
        self.os_agent = None
        self.screen_agent = None
        self.progress_tracker = ProgressTracker()
        self.current_scene_id = 1
        self._next_scene_id = 2  # 支持非线性场景
        self._total_turn_count = 0  # 累计回合数（跨场景）
        
    def _init_agents(self, fail_on_corrupted: bool = False) -> None:
        """
        内部方法：初始化 Agent 实例和恢复进度
        
        注意：此方法不产生任何副作用（如生成开场剧本），
        仅创建 Agent 实例并加载进度数据。
        
        Args:
            fail_on_corrupted: 是否在 progress.json 损坏时抛错
                - True: resume() 调用时使用，fail-fast 防止数据丢失
                - False: start() 调用时使用，损坏时使用默认进度继续新游戏
        
        Raises:
            RuntimeError: 仅当 fail_on_corrupted=True 且 progress.json 损坏时
        """
        self.os_agent = OperatingSystem(self.runtime_dir / "genesis.json")
        self.screen_agent = ScreenAgent(runtime_dir=self.runtime_dir)
        
        # 加载完整进度（含 turn_count 和 next_scene_id）
        progress = self.progress_tracker.load_progress(self.runtime_dir)
        
        if progress.is_corrupted:
            if fail_on_corrupted:
                raise RuntimeError(
                    f"progress.json 已损坏，无法恢复游戏。\n"
                    f"请手动修复备份文件或删除运行时目录：{self.runtime_dir}"
                )
            # 新游戏：损坏时使用默认进度（符合 Q4 规范）
            progress = ProgressData()  # 使用默认值
        
        self.current_scene_id = progress.current_scene_id
        self._next_scene_id = progress.next_scene_id  # 恢复非线性场景信息
        self._total_turn_count = progress.turn_count
    
    def start(self) -> str:
        """
        开始新游戏
        
        行为：初始化 Agent + 生成开场剧本 + 返回开场文本
        
        注意：即使 progress.json 损坏，也使用默认进度继续（符合 Q4 规范）
        """
        self._init_agents(fail_on_corrupted=False)  # 新游戏不 fail-fast
        
        # 新游戏：生成开场剧本（可能调用 LLM）
        self._generate_opening_script()
        
        # 返回开场文本
        return self._render_opening()
    
    def process_turn(self, player_input: str) -> TurnResult:
        # 回合开始时立即持久化，禁止切换引擎（防止重启后允许不安全切换）
        self.progress_tracker.save_progress(
            runtime_dir=self.runtime_dir,
            current_scene_id=self.current_scene_id,
            next_scene_id=self._next_scene_id,  # 使用已维护的值，支持非线性场景
            turn_count=self._total_turn_count,
            engine_type="osagent",
            can_switch_engine=False  # 回合中禁止切换
        )
        self.invalidate_resume_cache()  # 每次写入后失效缓存
        
        # 调用 OS Agent 的场景演绎
        loop_result = self.os_agent.run_scene_loop(
            runtime_dir=self.runtime_dir,
            world_dir=self.world_dir,
            max_turns=1,  # 单回合模式
            user_input_callback=lambda _: player_input,
            screen_callback=self._screen_callback
        )
        
        # 累加回合数（从 loop_result 或 OS Agent 内部状态获取）
        turns_this_call = loop_result.get("total_turns", 1)
        self._total_turn_count += turns_this_call
        
        # 检测是否到达场景边界（幕间）
        # ⚠️ 重要：scene_finished/next_scene_id 仅在 success=True 时有效
        # 失败回合不应推进场景或允许切换引擎
        is_success = loop_result.get("success", False)
        is_scene_boundary = is_success and loop_result.get("scene_finished", False)
        
        # 仅在成功到达边界时更新 scene_id 和 next_scene_id
        # 重要：非边界时保持 _next_scene_id 不变，避免覆盖上一幕边界计算的非线性路径
        if is_scene_boundary:
            self.current_scene_id = loop_result.get("next_scene_id", self.current_scene_id + 1)
            self._next_scene_id = loop_result.get("following_scene_id", self.current_scene_id + 1)
        # else: 保持 _next_scene_id 不变（已在 __init__ 或 _init_agents 中初始化）
        
        # 回合结束后落盘（边界时允许切换，否则禁止）
        self.progress_tracker.save_progress(
            runtime_dir=self.runtime_dir,
            current_scene_id=self.current_scene_id,
            next_scene_id=self._next_scene_id,  # 使用 loop_result 提供的值
            turn_count=self._total_turn_count,
            engine_type="osagent",
            can_switch_engine=is_scene_boundary  # 仅边界时允许切换
        )
        
        # 进度已更新，使缓存失效（确保后续 can_resume 反映最新状态）
        self.invalidate_resume_cache()
        
        return TurnResult(
            success=loop_result.get("success", False),
            text=self._last_rendered_text,
            scene_id=self.current_scene_id,
            turn_id=self._total_turn_count,
            npc_reactions=self._normalize_reactions(loop_result)
        )
    
    def save(self, save_name: str, at_boundary: bool = False) -> Path:
        """
        保存进度
        
        Args:
            save_name: 存档名称
            at_boundary: 是否在场景边界（幕间）。
                        True = 安全点，允许切换引擎
                        False = 场景中途（如 /quit），禁止切换
        """
        self.progress_tracker.save_progress(
            runtime_dir=self.runtime_dir, 
            current_scene_id=self.current_scene_id, 
            next_scene_id=self._next_scene_id,  # 使用已维护的值，支持非线性场景
            turn_count=self._total_turn_count,
            engine_type="osagent",
            can_switch_engine=at_boundary  # 仅边界时允许切换
        )
        # 保存后使缓存失效，允许后续重新检测（如返回菜单再次检查）
        self.invalidate_resume_cache()
        return self.runtime_dir / "plot" / "progress.json"
    
    # 调用示例：
    # session.save("auto", at_boundary=False)  # 用户 /quit 中途退出
    # session.save("scene_end", at_boundary=True)  # 幕间自动保存
    
    def _check_resume_state(self) -> Tuple[bool, Optional[str]]:
        """
        内部方法：检查恢复状态（带缓存，避免 load_progress 副作用）
        
        重要：load_progress() 在检测到损坏时会重命名文件，
        因此必须缓存首次检查结果，后续调用直接返回缓存。
        
        Returns:
            (can_resume, error_message)
        """
        # 使用实例级缓存，避免重复调用
        if hasattr(self, '_resume_state_cache'):
            return self._resume_state_cache
        
        progress_file = self.runtime_dir / "plot" / "progress.json"
        if not progress_file.exists():
            self._resume_state_cache = (False, "progress.json 不存在")
            return self._resume_state_cache
        
        progress = self.progress_tracker.load_progress(self.runtime_dir)
        if progress.is_corrupted:
            self._resume_state_cache = (False, "progress.json 已损坏，请手动修复备份文件")
            return self._resume_state_cache
        
        self._resume_state_cache = (True, None)
        return self._resume_state_cache
    
    def invalidate_resume_cache(self) -> None:
        """使缓存失效（如 progress.json 被外部修改后调用）"""
        if hasattr(self, '_resume_state_cache'):
            delattr(self, '_resume_state_cache')
    
    def can_resume(self) -> bool:
        """
        检查是否可以断点续传
        
        契约：can_resume()==True 必须保证 resume() 可执行不抛异常
        """
        can_resume, _ = self._check_resume_state()
        return can_resume
    
    def get_resume_error(self) -> Optional[str]:
        """
        获取无法恢复的原因
        
        注意：结果已缓存，与 can_resume() 保持一致
        """
        _, error = self._check_resume_state()
        return error
    
    def resume(self) -> str:
        """
        从断点恢复
        
        行为规范：
        1. 加载 progress.json 恢复 scene_id 和 turn_count
        2. 初始化 OS Agent（不重新生成开场剧本）
        3. 返回恢复提示文本（而非完整开场）
        
        与 start() 的区别：
        - start() = _init_agents(fail_on_corrupted=False) + 剧本生成 + 开场文本
        - resume() = _init_agents(fail_on_corrupted=True) + 恢复提示（fail-fast）
        
        前置条件：can_resume() 返回 True
        Raises：RuntimeError 如果 progress.json 损坏
        """
        # 仅初始化 Agent，不生成开场剧本（损坏时 fail-fast）
        self._init_agents(fail_on_corrupted=True)
        
        # 返回恢复提示而非开场文本
        return (
            f"📂 已从断点恢复\n"
            f"   场景: 第 {self.current_scene_id} 幕\n"
            f"   累计回合: {self._total_turn_count}\n"
            f"   继续你的冒险..."
        )
    
    def get_action_suggestions(self) -> List[str]:
        # 委托给 ActionSuggester
        from utils.action_suggester import ActionSuggester
        suggester = ActionSuggester()
        return suggester.generate_suggestions(...)  # 传入上下文
```

> **turn_count 来源说明**：
> - OS Agent 的 `run_scene_loop` 返回 `total_turns` 表示本次调用的回合数
> - 适配器维护 `_total_turn_count` 累计值，每次调用后累加
> - 也可从 `self.os_agent.turn_count`（如果 OS Agent 暴露此属性）直接读取

```python
# cli/gameengine_session.py

from config.cli_config import DevConfig

class GameEngineSession(GameSession):
    """GameEngine 的会话适配器（示例为核心方法节选，已修复 scene_id 映射和 progress.json 同步）"""
    
    def __init__(self, genesis_path: Path, config: DevConfig = None):
        self.genesis_path = genesis_path
        self.runtime_dir = genesis_path.parent
        self.config = config or DevConfig()
        self.engine = None
        self.progress_tracker = ProgressTracker()
        self._scene_id = 1       # 内部维护的 scene_id
        self._next_scene_id = 2  # 下一场景 ID
        self._turn_count = 0     # 累计回合数
        
    def start(self) -> str:
        self.engine = GameEngine(self.genesis_path)
        
        # 从 progress.json 恢复 scene_id 和 turn_count
        progress = self.progress_tracker.load_progress(self.runtime_dir)
        self._scene_id = progress.current_scene_id
        self._turn_count = progress.turn_count
        
        # GameEngine 采用线性策略：无论 progress 中 next_scene_id 是什么，
        # 都重置为 current + 1，确保与 process_turn 的线性推进一致
        # 
        # ⚠️ 已知限制：OS Agent 的非线性场景路径在切换到 GameEngine 后会丢失
        # 例如 OS→GE→OS 切换时，原本的分支信息无法恢复
        # 这是 GameEngine 不支持非线性场景的固有限制，非 bug
        self._next_scene_id = self._scene_id + 1
        
        return self.engine.start_game()
    
    def process_turn(self, player_input: str) -> TurnResult:
        # 回合开始时立即持久化，禁止切换引擎（防止重启后允许不安全切换）
        self.progress_tracker.save_progress(
            runtime_dir=self.runtime_dir,
            current_scene_id=self._scene_id,
            next_scene_id=self._next_scene_id,
            turn_count=self._turn_count,
            engine_type="gameengine",
            can_switch_engine=False  # 回合中禁止切换
        )
        self.invalidate_resume_cache()  # 每次写入后失效缓存
        
        result = self.engine.process_turn(player_input)
        
        # 从 GameEngine 获取回合数（非 OS Agent 特有的属性）
        self._turn_count = getattr(self.engine, 'turn_count', self._turn_count + 1)
        current_turn = self._turn_count
        
        # scene_id 映射策略（可配置，默认 10 轮/场景）
        turns_per_scene = getattr(self.config, 'TURNS_PER_SCENE', 10)
        computed_scene_id = (current_turn - 1) // turns_per_scene + 1
        
        # 场景切换时更新 scene_id 和 next_scene_id
        # 注意：GameEngine 采用线性推进策略（_next_scene_id = _scene_id + 1）
        # 这与 OS Agent 的非线性场景策略不同，但保证 progress.json 语义一致
        # （current_scene_id < next_scene_id 恒成立）
        if computed_scene_id > self._scene_id:
            self._scene_id = computed_scene_id
            self._next_scene_id = self._scene_id + 1  # 线性推进，保证语义正确
        
        # 回合结束后再次持久化（防止处理成功但进程异常退出导致进度丢失）
        self.progress_tracker.save_progress(
            runtime_dir=self.runtime_dir,
            current_scene_id=self._scene_id,
            next_scene_id=self._next_scene_id,
            turn_count=self._turn_count,  # 更新后的回合数
            engine_type="gameengine",
            can_switch_engine=False  # 仍处于回合间，非边界点
        )
        
        # 进度已更新，使缓存失效（确保后续 can_resume 反映最新状态）
        self.invalidate_resume_cache()
        
        return TurnResult(
            success=result.get("success", False),
            text=result.get("text", ""),
            error=result.get("error"),
            scene_id=self._scene_id,
            turn_id=current_turn,
            npc_reactions=result.get("npc_reactions", [])
        )
    
    def save(self, save_name: str, at_boundary: bool = False) -> Path:
        """
        保存游戏进度
        
        Args:
            save_name: 存档名称
            at_boundary: 是否在边界点（如关卡完成、存档点）
        """
        # 1. 保存 GameEngine 原生存档
        self.engine.save_game(save_name)
        
        # 2. 同步更新 progress.json（统一断点来源）
        self.progress_tracker.save_progress(
            runtime_dir=self.runtime_dir,
            current_scene_id=self._scene_id,
            next_scene_id=self._next_scene_id,
            turn_count=self._turn_count,
            engine_type="gameengine",
            can_switch_engine=at_boundary  # 仅边界时允许切换
        )
        
        # 保存后使缓存失效，允许后续重新检测
        self.invalidate_resume_cache()
        
        return self.runtime_dir / "saves" / f"{save_name}.json"
    
    def _check_resume_state(self) -> Tuple[bool, Optional[str]]:
        """
        内部方法：检查恢复状态（带缓存，避免 load_progress 副作用）
        
        重要：load_progress() 在检测到损坏时会重命名文件，
        因此必须缓存首次检查结果，后续调用直接返回缓存。
        """
        if hasattr(self, '_resume_state_cache'):
            return self._resume_state_cache
        
        progress_file = self.runtime_dir / "plot" / "progress.json"
        if not progress_file.exists():
            self._resume_state_cache = (False, "progress.json 不存在")
            return self._resume_state_cache
        
        progress = self.progress_tracker.load_progress(self.runtime_dir)
        if progress.is_corrupted:
            self._resume_state_cache = (False, "progress.json 已损坏，请手动修复备份文件")
            return self._resume_state_cache
        
        self._resume_state_cache = (True, None)
        return self._resume_state_cache
    
    def invalidate_resume_cache(self) -> None:
        """使缓存失效（如 progress.json 被外部修改后调用）"""
        if hasattr(self, '_resume_state_cache'):
            delattr(self, '_resume_state_cache')
    
    def can_resume(self) -> bool:
        """
        检查是否可以断点续传
        
        契约：can_resume()==True 必须保证 resume() 可执行不抛异常
        
        重要：
        - 仅检查 progress.json，不检查 saves/ 目录
        - 同时检查文件存在性和完整性（is_corrupted）
        """
        can_resume, _ = self._check_resume_state()
        return can_resume
    
    def get_resume_error(self) -> Optional[str]:
        """
        获取无法恢复的原因
        
        注意：结果已缓存，与 can_resume() 保持一致
        """
        _, error = self._check_resume_state()
        return error
    
    def resume(self) -> str:
        """
        从断点恢复（语义等同于 start() 但走恢复路径）
        
        行为规范：
        1. 检查 progress.json 存在性和完整性
        2. 加载 progress.json 恢复 scene_id 和 turn_count
        3. 初始化 GameEngine（跳过新游戏开场）
        4. 返回恢复提示文本
        
        前置条件：can_resume() 返回 True
        返回值：统一格式的恢复提示字符串
        
        Raises:
            RuntimeError: 如果 progress.json 不存在或损坏
        """
        # 前置检查：使用缓存的结果（存在性+完整性）
        if not self.can_resume():
            # 使用 get_resume_error() 获取具体原因（与 B-07a 契约一致）
            error = self.get_resume_error() or "未知原因"
            raise RuntimeError(f"无法恢复：{error}")
        
        # 此时 can_resume()=True，可以安全加载
        progress = self.progress_tracker.load_progress(self.runtime_dir)
        
        self.engine = GameEngine(self.genesis_path)
        
        # 从 progress 恢复状态
        self._scene_id = progress.current_scene_id
        self._next_scene_id = progress.next_scene_id
        self._turn_count = progress.turn_count
        
        # 恢复 GameEngine 内部状态（如果支持）
        if hasattr(self.engine, 'restore_from_turn'):
            self.engine.restore_from_turn(self._turn_count)
        
        return (
            f"📂 已从断点恢复\n"
            f"   场景: 第 {self._scene_id} 幕\n"
            f"   累计回合: {self._turn_count}\n"
            f"   继续你的冒险..."
        )
    
    def get_action_suggestions(self) -> List[str]:
        # GameEngine 可从 engine.current_context 推导建议
        return self.engine.get_available_actions() if hasattr(self.engine, 'get_available_actions') else []
```

> **适配器示例说明**：以上代码为核心方法节选，完整实现还包括私有辅助方法、错误处理和日志记录，详见实际代码。

> **TURNS_PER_SCENE 配置说明**：
> - 默认值 `10` 基于 OS Agent 流程的平均场景长度
> - 可通过 `config/cli_config.py` 的 `DevConfig.TURNS_PER_SCENE` 配置
> - 也可从 `genesis.json` 的 `plot_settings.avg_scene_turns` 动态读取（如果存在）
> - 切换引擎时，以 `progress.json` 记录的 `current_scene_id` 为准，不重新计算

### 5.4 会话工厂

```python
# cli/session_factory.py

class SessionFactory:
    """会话工厂（根据配置选择引擎）"""
    
    @staticmethod
    def create(
        runtime_dir: Path,
        world_dir: Path,
        engine_type: str = "osagent"
    ) -> GameSession:
        if engine_type == "osagent":
            return OSAgentSession(runtime_dir, world_dir)
        elif engine_type == "gameengine":
            genesis_path = runtime_dir / "genesis.json"
            return GameEngineSession(genesis_path)
        else:
            raise ValueError(f"未知引擎类型: {engine_type}")
```

### 5.5 运行时数据兼容性保证

**统一的运行时目录结构**：

```
data/runtime/<世界名>_<时间戳>/
├── genesis.json              # 必须（两种引擎共用）
├── plot/
│   ├── current_script.json   # 必须（OS Agent 主要使用）
│   ├── current_scene.json    # 可选
│   └── progress.json         # 必须（统一的断点续传）
├── ws/
│   └── world_state.json      # 必须（两种引擎共用）
├── screen/
│   └── scene_*.json          # 可选（Screen Agent 输出）
├── saves/                    # GameEngine 存档目录
└── init_summary.json         # 初始化摘要
```

**progress.json 统一格式（v2，向后兼容）**：

**示例 1：场景中途状态（默认/初始状态）**

> `can_switch_engine: false` — 保守策略（自 v3.6 起），仅边界点为 true

```json
{
  "format_version": 2,
  "current_scene_id": 3,
  "next_scene_id": 4,
  "turn_count": 15,
  "engine_type": "osagent",
  "updated_at": "2025-12-29T10:30:00",
  "can_switch_engine": false
}
```

**示例 2：到达边界点（幕间/存档点）时**

> `can_switch_engine: true` — 边界点允许切换引擎
> 注意：到达边界时 `current_scene_id` 和 `next_scene_id` 会被推进

```json
{
  "format_version": 2,
  "current_scene_id": 4,
  "next_scene_id": 5,
  "turn_count": 20,
  "engine_type": "osagent",
  "updated_at": "2025-12-29T10:45:00",
  "can_switch_engine": true
}
```

---

## 6. 公共模块规划（补充版）

> 注：第3.4节和第4.4节已详细定义了需要抽取的模块，本节补充目录结构和额外模块。

### 6.1 完整的模块目录结构

```
cli/                              # 新建目录：CLI 相关模块
├── __init__.py
├── world_manager.py              # 世界管理
├── game_session.py               # 统一会话接口（抽象基类）
├── osagent_session.py            # OS Agent 会话适配器
├── gameengine_session.py         # GameEngine 会话适配器
├── session_factory.py            # 会话工厂
├── genesis_runner.py             # 创世组运行器
├── illuminati_runner.py          # 光明会运行器
├── checkpoint.py                 # 检查点管理
├── player_profile.py             # 玩家角色管理
├── dev_tools.py                  # 开发者工具
└── cli_utils.py                  # CLI 通用工具

utils/                            # 现有目录：新增模块
├── (现有模块保持不变)
├── concurrency.py                # 并发控制（公开 API，替代私有 _get_semaphore）
├── progress_tracker.py           # 断点续传
├── action_suggester.py           # 行动建议生成
├── screen_renderer.py            # 终端渲染
├── player_log_filter.py          # 玩家模式日志过滤
└── exception_handler.py          # 异常友好化处理
```

### 6.2 并发控制模块（公开 API）

> 解决审阅意见：直接引入 _get_semaphore 私有函数违背低耦合目标

```python
# utils/concurrency.py
"""
LLM 并发控制模块（从 run_world_builder.py 抽取并公开化）

用法：
    from utils.concurrency import llm_concurrency
    
    async with llm_concurrency.get_semaphore():
        result = await llm.ainvoke(...)
"""

import asyncio
import os
import weakref

class LLMConcurrencyManager:
    """线程安全的 LLM 并发控制器"""
    
    def __init__(self, max_concurrency: int = None):
        self._concurrency = max_concurrency or int(os.getenv("LLM_CONCURRENCY", "5"))
        self._semaphores: weakref.WeakKeyDictionary = weakref.WeakKeyDictionary()
    
    def get_semaphore(self) -> asyncio.Semaphore:
        """获取与当前事件循环绑定的 Semaphore（公开 API）"""
        try:
            loop = asyncio.get_running_loop()
        except RuntimeError:
            loop = None
        
        if loop:
            sem = self._semaphores.get(loop)
            if sem is None:
                sem = asyncio.Semaphore(self._concurrency)
                self._semaphores[loop] = sem
            return sem
        return asyncio.Semaphore(self._concurrency)
    
    def set_concurrency(self, value: int):
        """动态调整并发数"""
        self._concurrency = value
    
    @property
    def concurrency(self) -> int:
        return self._concurrency

# 全局单例
llm_concurrency = LLMConcurrencyManager()
```

### 6.3 配置文件

```python
# config/cli_config.py

from dataclasses import dataclass

@dataclass
class PlayerConfig:
    """玩家入口配置"""
    SHOW_LOGS: bool = False
    SHOW_AGENT_STATUS: bool = False
    SHOW_PERFORMANCE: bool = False
    ENABLE_VIBE: bool = True
    ENABLE_SCREEN_AGENT: bool = True
    DEFAULT_MAX_TURNS: int = 15
    LOG_LEVEL: str = "WARNING"
    ENGINE_TYPE: str = "osagent"

@dataclass
class DevConfig:
    """开发者入口配置"""
    SHOW_LOGS: bool = True
    SHOW_AGENT_STATUS: bool = True
    SHOW_PERFORMANCE: bool = True
    ENABLE_VIBE: bool = True
    ENABLE_SCREEN_AGENT: bool = True  # 仅 OS Agent 支持，见兼容性说明
    DEFAULT_MAX_TURNS: int = 50
    LOG_LEVEL: str = "DEBUG"
    ENGINE_TYPE: str = "osagent"
    DEFAULT_CONCURRENCY: int = 5
    ENABLE_PARALLEL: bool = True
    
    # GameEngine 引擎的场景映射配置
    # 每 N 轮对话视为一个场景（用于 scene_id 计算）
    # 此值应与 OS Agent 的平均场景长度保持一致
    TURNS_PER_SCENE: int = 10
```

---

## 7. 迁移计划（修订版）

### 7.1 阶段划分

| 阶段 | 内容 | 预计工时 | 前置条件 |
|------|------|----------|----------|
| 阶段0 | 抽取公共模块到 cli/ 和 utils/ | 4小时 | 无 |
| 阶段1 | 实现 GameSession 统一接口 | 2小时 | 阶段0 |
| 阶段2 | 实现 play.py | 3小时 | 阶段0, 阶段1 |
| 阶段3 | 实现 dev.py | 3小时 | 阶段0, 阶段1 |
| 阶段4 | 旧入口改为 wrapper | 1小时 | 阶段2, 阶段3 |
| 阶段5 | 验收测试 | 3小时 | 阶段4 |
| 阶段6 | 文档更新 | 1小时 | 阶段5 |

**总工时**：约17小时（含充分测试）

### 7.2 旧文件处理策略

> 解决审阅意见：先抽到新模块再改入口，避免断依赖

| 文件 | 阶段0 | 阶段4 | 弃用期后(v1.0.0) |
|------|-------|-------|------------------|
| `main.py` | 核心逻辑抽取到 `cli/osagent_session.py` | 改为 wrapper 调用 play.py | 删除 |
| `play_game.py` | 核心逻辑抽取到 `cli/world_manager.py` 等 | 改为 wrapper 调用 play.py | 删除 |
| `run_game.py` | 核心逻辑抽取到 `cli/genesis_runner.py` 等 | 改为 wrapper 调用 dev.py | 删除 |
| `run_world_builder.py` | 核心逻辑抽取到 `cli/genesis_runner.py`, `cli/checkpoint.py` | 改为 wrapper 调用 dev.py | 删除 |
| `run_creator_god.py` | 无需抽取（功能重复） | 改为 wrapper 调用 dev.py | 删除 |
| `game_engine.py` | 保留（核心引擎类） | 保留 | 保留 |

### 7.3 兼容性方案（跨平台）

> 解决审阅意见：ln -s 在 Windows 不可用，改用 wrapper

**方案：保留旧入口作为薄封装 wrapper**

```python
# play_game.py (弃用期保留)
"""
⚠️ 此入口已弃用，请使用 play.py 替代。
将在 v1.0.0 版本移除。
"""
import sys

def main():
    # 直接输出到 stderr 确保用户可见（避免 DeprecationWarning 被隐藏）
    print(
        "\n"
        "=" * 60 + "\n"
        "⚠️  play_game.py 已弃用\n"
        "   请使用 python play.py 替代\n"
        "   此入口将在 v1.0.0 版本移除\n"
        "=" * 60 + "\n",
        file=sys.stderr
    )
    
    # 透传命令行参数
    from cli.play import main as play_main
    play_main(sys.argv[1:])  # 传递除脚本名外的所有参数

if __name__ == "__main__":
    main()
```

```python
# run_game.py (弃用期保留)
"""
⚠️ 此入口已弃用，请使用 dev.py 替代。
将在 v1.0.0 版本移除。
"""
import sys

def main():
    # 直接输出到 stderr 确保用户可见（避免 DeprecationWarning 被隐藏）
    print(
        "\n"
        "=" * 60 + "\n"
        "⚠️  run_game.py 已弃用\n"
        "   请使用 python dev.py 替代\n"
        "   此入口将在 v1.0.0 版本移除\n"
        "=" * 60 + "\n",
        file=sys.stderr
    )
    
    # 透传命令行参数
    from cli.dev import main as dev_main
    dev_main(sys.argv[1:])  # 传递除脚本名外的所有参数

if __name__ == "__main__":
    main()
```

> **注意**：`play_main()` 和 `dev_main()` 的函数签名需支持接收参数列表：
> ```python
> def main(argv: List[str] = None):
>     if argv is None:
>         argv = sys.argv[1:]
>     parser.parse_args(argv)
> ```

**弃用时间线**：

| 版本 | 状态 | 行为 |
|------|------|------|
| v0.9.x | 当前 | 旧入口正常工作 |
| v0.10.0 | 弃用开始 | 旧入口显示警告，功能正常 |
| v0.11.0 | 弃用中期 | 旧入口警告更醒目 |
| v1.0.0 | 弃用结束 | 删除旧入口 |

### 7.4 验收测试清单

> 解决审阅意见：阶段4只写"测试与调优"，没有最小验收测试清单

#### 7.4.1 play.py 验收测试

| 测试项 | 测试内容 | 验收标准 |
|--------|----------|----------|
| **P-01** | 启动画面 | 显示完整 Banner，无乱码 |
| **P-02** | 世界列表 | 正确显示所有可用世界及其信息 |
| **P-03** | 存档列表 | 正确显示指定世界的存档 |
| **P-04** | 新游戏 | 可创建新运行时目录并开始游戏 |
| **P-05** | 继续游戏 | 可从现有存档继续游戏 |
| **P-06** | 断点续传 | 退出再进入，scene_id 连续不重置 |
| **P-07** | 角色创建 | 玩家输入的角色信息正确保存 |
| **P-08** | Screen Agent | 场景渲染输出格式正确 |
| **P-09** | 行动建议 | 生成2个合理的行动建议 |
| **P-10** | 日志静默 | 终端无 Agent 日志，logs/ 有完整日志 |
| **P-11** | 异常处理 | LLM 超时/网络错误显示友好提示 |
| **P-12** | 幕间过渡 | 幕结束后正确进入下一幕 |
| **P-13** | 退出保存 | /quit 或 Ctrl+C 正确保存进度 |
| **P-14** | 旧运行时兼容 | 可无缝继续 v0.9.0 创建的存档 |

#### 7.4.2 dev.py 验收测试

| 测试项 | 测试内容 | 验收标准 |
|--------|----------|----------|
| **D-01** | 无参数启动 | 显示交互菜单，默认 OS Agent |
| **D-02** | --stage genesis | 正确运行创世组 |
| **D-03** | --stage illuminati | 正确运行光明会初始化 |
| **D-04** | --stage game | 正确启动游戏 |
| **D-05** | --novel | 指定小说文件正确处理 |
| **D-06** | --world | 指定世界正确处理 |
| **D-07** | --parallel | 并行模式正确启用 |
| **D-08** | --concurrency | 并发数正确生效 |
| **D-09** | --resume | 游戏续玩正确工作（布尔标志） |
| **D-09b** | --continue-build | 创世组断点续传正确工作（带世界名参数） |
| **D-10** | --verbose | 详细日志正确输出 |
| **D-11** | --auto-test | 自动测试模式正确运行 |
| **D-12** | --engine gameengine | GameEngine 模式正确工作 |
| **D-13** | --list-worlds | 世界列表格式正确 |
| **D-14** | 检查点保存 | 创世组中断后可正确恢复 |
| **D-15** | 进度显示 | 阶段3角色档案进度条正确 |

#### 7.4.3 兼容性测试

| 测试项 | 测试内容 | 验收标准 |
|--------|----------|----------|
| **C-01** | wrapper 调用 | play_game.py 正确调用 play.py |
| **C-02** | 弃用警告 | wrapper 显示弃用警告 |
| **C-03** | 参数透传 | 命令行参数正确传递 |
| **C-04** | 引擎切换 | OS Agent ↔ GameEngine 可互换 |
| **C-05** | 跨版本存档 | 新入口可读取旧版本存档 |

#### 7.4.4 边界测试

| 测试项 | 测试内容 | 验收标准 |
|--------|----------|----------|
| **B-01** | 空世界目录 | 正确提示需要先构建世界 |
| **B-02** | 损坏的检查点 | 正确处理并重新开始 |
| **B-03** | LLM 连续超时 | 正确重试或降级 |
| **B-04** | 磁盘空间不足 | 友好提示而非崩溃 |
| **B-05** | 并发数过高 | API 限流时正确退避 |
| **B-06** | 仅 saves/ 存在 | `can_resume()` 返回 False，调用方提示需从新游戏开始 |
| **B-07** | progress.json 存在且未损坏 | `can_resume()` 返回 True，正确恢复 |
| **B-07a** | progress.json 存在但已损坏 | `can_resume()` 返回 False，调用方通过 `get_resume_error()` 获取原因并提示用户（见下方说明） |
| **B-08** | engine_type 与 CLI 冲突 | 显示警告，按优先级规则执行（CLI > progress > default） |
| **B-09** | can_switch_engine=false 时强制切换 | 拒绝切换并提示原因 |
| **B-10** | 引擎切换后脚本缺失 | OS→GE：忽略 current_script.json；GE→OS：从 progress 重建场景 |
| **B-11** | 引擎切换后存档缺失 | GE→OS：正常继续；OS→GE：从 progress 的 turn_count 恢复 |
| **B-12** | GameEngine + Screen Agent 开关 | 显示警告"Screen Agent 仅支持 OS Agent"，忽略该选项 |
| **B-13** | resume() 在 can_resume()=false 时调用 | 抛出 RuntimeError，不静默回退 |
| **B-14** | progress.json 损坏 | 备份(带时间戳)，--resume 模式 fail-fast，新游戏模式用默认进度 |
| **B-15** | current_script.json 损坏 | 警告 + 根据 progress.json 的 scene_id 重新生成剧本 |
| **B-16** | world_state.json 损坏 | 交互模式提供选项，非交互模式 fail-fast（见下方说明） |
| **B-17** | 缓存失效路径 | 修复损坏文件后 invalidate_resume_cache()，can_resume() 返回最新状态 |
| **B-18** | v1 进度缺少 can_switch_engine 字段 | 默认 False（保守策略），can_switch_engine() 返回 False，需到达边界点后才能切换 |

> **B-07a 提示路径说明**：
> 
> `can_resume()` 仅返回布尔值，调用方需通过辅助方法获取错误原因：
> ```python
> class GameSession:
>     def can_resume(self) -> bool: ...
>     
>     def get_resume_error(self) -> Optional[str]:
>         """获取无法恢复的原因（can_resume()=False 时调用）"""
>         progress_file = self.runtime_dir / "plot" / "progress.json"
>         if not progress_file.exists():
>             return "progress.json 不存在"
>         progress = self.progress_tracker.load_progress(self.runtime_dir)
>         if progress.is_corrupted:
>             return "progress.json 已损坏，请手动修复备份文件"
>         return None  # 可恢复
> 
> # 调用方使用示例
> if not session.can_resume():
>     error = session.get_resume_error()
>     print(f"❌ 无法续玩：{error}", file=sys.stderr)
> ```

> **B-14~B-16 数据一致性与非交互式处理说明**：
> 
> **B-14 (progress.json 损坏)**：
> - `--resume` 模式：fail-fast，拒绝启动，提示用户修复
> - 新游戏模式：使用默认进度继续
> 
> **B-16 (world_state.json 损坏) 非交互式处理**：
> - 检测 `--auto-test` 或非 TTY 环境时，**fail-fast** 而非等待输入
> - 返回非零退出码，CI/自动化可捕获失败
> ```python
> if is_non_interactive():
>     print("❌ world_state.json 损坏，非交互模式下无法恢复", file=sys.stderr)
>     sys.exit(1)
> else:
>     # 交互模式：询问用户选择
>     choice = input("选择 (1) 重置到初始状态 或 (2) 退出并手动修复: ")
> ```

> **B-17 (缓存失效路径)**：
> 
> 测试场景：用户在同一进程内修复损坏的 progress.json 后，需要能够正确检测恢复状态。
> 
> ```python
> # 测试步骤
> def test_cache_invalidation():
>     session = OSAgentSession(runtime_dir, world_dir)
>     
>     # 1. 损坏 progress.json
>     corrupt_progress_file(runtime_dir)
>     
>     # 2. 首次检查返回 False（缓存结果）
>     assert session.can_resume() == False
>     assert session.get_resume_error() == "progress.json 已损坏，请手动修复备份文件"
>     
>     # 3. 模拟用户修复
>     restore_progress_file(runtime_dir)
>     
>     # 4. 不失效缓存时仍返回旧结果（验证缓存生效）
>     # assert session.can_resume() == False  # 仍是旧缓存
>     
>     # 5. 手动失效缓存
>     session.invalidate_resume_cache()
>     
>     # 6. 重新检查返回最新状态
>     assert session.can_resume() == True
>     assert session.get_resume_error() is None
> ```
> 
> 预期：缓存失效后，can_resume() 和 get_resume_error() 反映最新文件状态。

> **B-18 (v1 进度缺字段兼容性)**：
> 
> 测试场景：旧版 v1 进度文件缺少 `can_switch_engine` 字段时的行为。
> 
> **注意**：此测试使用 `OSAgentSession`，因为 `GameEngineSession.process_turn()` 不会将 `can_switch_engine` 置为 True。
> 
> ```python
> # 测试步骤
> def test_v1_progress_missing_can_switch():
>     # 1. 创建 v1 格式进度（无 can_switch_engine 字段）
>     v1_progress = {
>         "current_scene_id": 2,
>         "next_scene_id": 3
>     }
>     write_progress_file(runtime_dir, v1_progress)
>     
>     # 2. 加载进度，验证默认值为 False（保守策略）
>     progress = progress_tracker.load_progress(runtime_dir)
>     assert progress.can_switch_engine == False  # DEFAULT_CAN_SWITCH=False
>     
>     # 3. 验证 can_switch_engine() 返回 False
>     can_switch, reason = can_switch_engine(runtime_dir)
>     assert can_switch == False
>     assert "处于场景/回合中途" in reason
>     
>     # 4. 通过显式 save(at_boundary=True) 触发边界点（固定触发，不依赖 process_turn 结果）
>     session = OSAgentSession(runtime_dir, world_dir)
>     session.save("boundary_test", at_boundary=True)
>     
>     # 5. 验证边界点后 can_switch_engine 变为 True
>     can_switch, _ = can_switch_engine(runtime_dir)
>     assert can_switch == True  # 边界点允许切换
> ```
> 
> 预期：v1 进度缺字段时默认 `can_switch_engine=False`，通过 `save(at_boundary=True)` 可显式切换到边界状态。

---

## 8. 关键决策点（修订版）

### 8.1 游戏引擎选择

| 方案 | 优点 | 缺点 | 推荐 |
|------|------|------|------|
| GameEngine | 成熟稳定、功能完整 | 不集成Screen Agent | ❌ |
| OS Agent流程 | 集成Screen Agent、与测试一致 | 代码分散 | ✅ |
| 混合方案 + 统一契约 | 兼顾两者优点，通过 GameSession 抽象隔离差异 | 需要额外整合工作 | ⭐ 推荐 |

**最终决策**：采用 **混合方案 + 统一运行契约**

- 通过 `GameSession` 抽象接口统一两种引擎的行为
- 运行时数据格式统一（`progress.json` 包含引擎类型标识）
- 支持运行时切换引擎（在断点续传兼容的前提下）

```python
# 默认行为（使用 resolve_engine() 统一解析）

# play.py - 固定 OS Agent（不区分新开局/续玩）
play.py             → OSAgentSession   # 沉浸体验，强制 Screen Agent

# dev.py - 新开局
dev.py              → OSAgentSession   # 默认 OS Agent
dev.py --engine gameengine → GameEngineSession  # 显式指定

# dev.py - 续玩（--resume 必须配合 --runtime）
dev.py --resume --runtime data/runtime/xxx     → GameEngineSession  # 继承存档引擎
dev.py --resume --runtime data/runtime/xxx --engine osagent → OSAgentSession  # CLI 覆盖
```

### 8.2 日志处理策略

| 模式 | 终端输出 | 文件日志 | 异常处理 |
|------|----------|----------|----------|
| 玩家模式 | 仅游戏内容 | 完整日志 | 友好提示(终端) + 堆栈(文件) |
| 开发者模式 | 完整日志 | 完整日志 | 完整堆栈 |
| 静默模式 | 无输出 | 完整日志 | 仅文件记录 |

**日志文件位置**：`logs/game_YYYYMMDD_HHMMSS.log`

### 8.3 Screen Agent 集成

| 入口 | Screen Agent | 说明 |
|------|--------------|------|
| play.py | ✅ 必须启用 | 沉浸体验核心 |
| dev.py (默认) | ✅ 默认启用 | 与生产一致 |
| dev.py --no-screen-agent | ❌ 可禁用 | 调试/测试用 |

### 8.4 断点续传语义

**保证**：无论使用哪种引擎，断点续传的语义一致。

| 状态 | 存储位置 | 格式（v2，向后兼容） |
|------|----------|----------------------|
| 场景进度 | `plot/progress.json` | 见下方完整字段列表 |
| 世界状态 | `ws/world_state.json` | 标准世界状态格式 |
| 游戏存档 | `saves/*.json` | GameEngine 格式（兼容） |

**progress.json 完整字段（v2）**：

| 字段 | 类型 | 必须 | 说明 |
|------|------|------|------|
| `format_version` | int | ✅ | 格式版本，当前为 2 |
| `current_scene_id` | int | ✅ | 当前场景 ID |
| `next_scene_id` | int | ✅ | 下一场景 ID |
| `turn_count` | int | ✅ | 累计回合数 |
| `engine_type` | str | ✅ | 引擎类型：`osagent` 或 `gameengine` |
| `updated_at` | str | ✅ | 更新时间戳 |
| `can_switch_engine` | bool | ✅ | 是否可切换引擎 |

> 注：v1 格式（旧版）仅含 `current_scene_id` 和 `next_scene_id`，加载时自动补齐其他字段默认值。

**恢复优先级**：
1. 读取 `progress.json`（自动补齐缺失字段）
2. 若不存在，读取 `current_script.json`
3. 若都不存在，从第1幕开始

---

## 9. 附录

### 9.1 颜色代码参考

```python
# 终端颜色代码
COLORS = {
    "RESET": "\033[0m",
    "BOLD": "\033[1m",
    "DIM": "\033[2m",
    "CYAN": "\033[36m",      # 场景头
    "YELLOW": "\033[33m",    # 角色名
    "GREEN": "\033[32m",     # 玩家
    "GRAY": "\033[90m",      # 动作/旁白
    "WHITE": "\033[97m",     # 台词
    "MAGENTA": "\033[35m",   # 环境描述
    "RED": "\033[31m",       # 错误
    "BLUE": "\033[34m",      # 系统提示
}
```

### 9.2 命令行参数完整列表（dev.py）

```
# 运行控制
--stage         运行阶段 [genesis|illuminati|game|all]
--engine        游戏引擎 [osagent|gameengine]（默认 osagent）
--world         世界名称
--novel         小说文件名
--runtime       运行时目录路径

# 断点续传（两种模式，互斥）
--resume              游戏续玩（布尔标志）
                      约束：必须配合 --runtime 指定运行时目录
--continue-build NAME 创世组断点续传（带参数）
                      约束：必须配合 --stage genesis
注意：--resume 和 --continue-build 互斥，不能同时使用

# 并行化控制
--parallel      启用并行模式（默认）
--no-parallel   禁用并行模式
--concurrency   并发数（默认5）

# 日志控制
--verbose       详细日志
--quiet         静默模式

# 游戏运行控制
--auto-test     自动测试模式
--max-turns     最大回合数

# 功能开关
--enable-vibe   启用氛围生成
--disable-vibe  禁用氛围生成
--enable-logic  启用逻辑验证
--disable-logic 禁用逻辑验证
--screen-agent     启用 Screen Agent（默认）
--no-screen-agent  禁用 Screen Agent

# 信息查询
--list-worlds   列出所有世界
--list-novels   列出所有小说
--list-runtimes 列出运行时目录

# 维护工具
--cleanup-runtimes 清理运行时目录
--keep          保留最近N个运行时

# 调试支持
--debug         调试模式（断点调试支持）
--profile       性能分析
```

---

## 10. 总结

### 10.1 规划要点

本规划旨在将现有 **6个入口文件** 整合为 **2个**：

1. **play.py**：面向玩家，提供简洁沉浸的游戏体验
2. **dev.py**：面向开发者，提供完整的调试和控制能力

### 10.2 关键改进（基于审阅意见）

**第一轮审阅修订 (v1.1)**：

| 审阅意见 | 解决方案 |
|----------|----------|
| 直接从旧入口导入会断依赖 | 阶段0 先抽取公共模块，再实现新入口 |
| 混合方案没有统一运行契约 | 定义 `GameSession` 抽象接口，两种引擎各实现适配器 |
| ln -s 在 Windows 不可用 | 改用 wrapper 脚本，显示弃用警告 |
| 日志策略不明确 | 详细定义日志过滤器、异常处理器、文件写入规则 |
| 引入私有函数 _get_semaphore | 抽取为公共模块 `utils/concurrency.py` |
| 测试清单不明确 | 补充 40+ 条验收测试项 |

**第二轮审阅修订 (v1.2)**：

| 审阅意见 | 解决方案 |
|----------|----------|
| wrapper 未透传参数 | 修改 wrapper 传递 `sys.argv[1:]`，`main()` 接受参数列表 |
| GameEngine 用 turn_count 作 scene_id | 添加 TURNS_PER_SCENE 映射逻辑，`save()` 同步更新 progress.json |
| progress.json 新字段破坏兼容 | 添加 `format_version` 字段，加载时兼容处理 |
| DeprecationWarning 可能被隐藏 | 改为直接输出到 stderr |
| GAME_LEVEL 未定义 | 添加完整的日志级别注册代码 |
| 参数列表缺 --engine | 补充 `--engine [osagent\|gameengine]` 参数 |

**第三轮审阅修订 (v1.3)**：

| 审阅意见 | 解决方案 |
|----------|----------|
| ProgressTracker 接口不一致 | 统一 `save_progress()` 签名，添加 `ProgressData` 类型 |
| TURNS_PER_SCENE 固定值 | 改为可配置（`DevConfig.TURNS_PER_SCENE`），并添加说明 |
| load_progress v1 未补齐默认值 | 所有分支统一返回 `ProgressData`，缺失字段使用默认值 |
| Q2 弃用示例仍用 DeprecationWarning | 统一改为 stderr 输出，与 7.3 一致 |
| 8.4 表格未更新为 v2 | 添加完整字段列表表格，标注各字段用途 |

**第四轮审阅修订 (v1.4)**：

| 审阅意见 | 解决方案 |
|----------|----------|
| save_progress 未暴露 v2 必须字段 | 添加 `can_switch_engine` 为显式参数（v2.1 更新），`format_version`/`updated_at` 仍由函数内部自动补齐 |
| load_resume_scene_id 可能不复用 load_progress | 明确函数实现为 `return self.load_progress(...).current_scene_id`，避免语义漂移 |

### 10.3 整合后的能力

| 能力 | play.py | dev.py |
|------|---------|--------|
| Screen Agent 渲染 | ✅ 必须 | ✅ 可选 |
| 断点续传 | ✅ | ✅ |
| 并行化构建 | ❌ | ✅ |
| 行动建议 | ✅ | ❌ |
| 详细日志 | ❌ (仅文件) | ✅ |
| 命令行参数 | ❌ (交互式) | ✅ 丰富 |
| 引擎切换 | ❌ (固定 OS Agent) | ✅ 可选 |
| 世界构建 | ❌ | ✅ |

### 10.4 迁移时间线

```
v0.9.x (当前)
    │
    ├── 阶段0-3: 抽取模块 + 实现新入口
    │
    ▼
v0.10.0 (弃用开始)
    │   - 新入口 play.py / dev.py 可用
    │   - 旧入口作为 wrapper 保留，显示弃用警告
    │
    ├── 阶段4-6: 测试 + 文档
    │
    ▼
v0.11.0 (弃用中期)
    │   - 弃用警告更醒目
    │
    ▼
v1.0.0 (弃用结束)
        - 删除旧入口
```

### 10.5 风险与缓解

| 风险 | 概率 | 影响 | 缓解措施 |
|------|------|------|----------|
| 旧存档不兼容 | 低 | 高 | 验收测试 C-05 覆盖 |
| 引擎切换丢进度 | 中 | 中 | 统一 progress.json 格式 |
| 并发控制失效 | 低 | 中 | 公共模块单元测试 |
| 日志泄漏到终端 | 中 | 低 | PlayerLogFilter 严格过滤 |
| OS→GE→OS 非线性分支丢失 | 中 | 中 | 文档标注已知限制，GameEngine 不支持非线性场景为固有特性 |

---

**报告完成日期**: 2025-12-30  
**修订版本**: v4.0  
**预计实施周期**: 2-3天（含测试）  
**总工时**: 约17小时  
**负责人**: [待指定]

> **v4.0 关键修复说明**：
> - 修复 `max_turns=1` 导致玩家输入无法进入场景循环
> - 修复缺少 `dispatch_script_to_actors()` 导致 NPC 没有剧本
> - 修复 `scene_finished` vs `scene_ended` 字段名不匹配
> - 修复缺少 `process_scene_transition()` 导致幕间不推进

