
### 1. 游戏产品定义 (Product Concept)

* **项目名称：** Infinite Story (无限故事机)
* **核心体验：** **生成式互动叙事游戏**。
* **玩法流程：** 用户上传一本小说（约 2w 字切片，现代都市/剧情向）-> AI 自动解析并重构世界 -> 用户扮演一个新角色进入该世界 -> 通过自然语言指令推动剧情发展。
* **产品形态：** 纯 Python 命令行界面 (CLI)。
* **关键特征：** 无数值战斗、无 RPG 属性。核心在于**逻辑严谨的剧情模拟**和**高沉浸感的社会互动**。

---

### 2. Agent 角色职能 (Agent Roles)


系统分为**离线构建**与**在线运行**两大部分。
每个agent都要有一个llm作为大脑,使用langchain进行开发

#### **A. 离线构建者 (The Creator)**
* **架构师 (The Architect):**
    * **职责：** **ETL 引擎**。只运行一次。阅读小说原文，提取世界观、人物档案、剧情节点，生成标准化的 `Genesis.json` 数据包。




#### **B. 在线运行系统 (The Runtime System)**

**第一层：安检与中枢 **
* **逻辑审查官 (Logic):**
    * **职责：** **独立中间件**。不负责创作，只负责“审核”。
    * **功能：** 拦截不符合世界观的用户输入（如现代社会用魔法），拦截产生幻觉的 AI 输出。
* **信息中枢 (OS):**
    * **职责：** **总线与路由器**。
    * **功能：** 系统的主程序（非 LLM）。负责在各层级 Agent 之间传递消息、维护全局状态变量。

**第二层：光明会 (The Illuminati - 逻辑大脑)**
* **世界状态运行者 (WS):**
    * **职责：** **仿真引擎**。
    * **功能：** 掌管时间流逝、计算“与此同时”其他地方发生的事（Off-screen Events）、天气变化、维护 NPC 的日程表和社会状态。
* **命运编织者 (Plot):**
    * **职责：** **导演/编剧**。
    * **功能：** 掌管剧本大纲。决定何时触发剧情节点、何时制造高潮、指导 NPC 该做出什么情绪反应。并生成一轮对话中下一个场景的剧本
* **氛围感受者 (Vibe):**
    * **职责：** **美工/摄影**。
    * **功能：** 生成沉浸式的环境描写、感官细节（光影、声音、气味）。

**第三层：演员组 (The Cast - 表现层)**
* **NPC Agents:**
    * **职责：** **沉浸式扮演**。
    * **功能：** 不知道剧情走向，只根据收到的“剧本”和“人设”生成具体的台词和行为。

---

#### 世界初始化：
离线构建者形成genesis.json后，根据小说中角色的数量生成角色，每个角色从genesis.json中提取自己的人设数据来生成角色。WS根据Genesis.json进行初始化。Plot根据Genesis.json生成第一个场景和剧本，并将剧本分发给Vibe、WS和各个角色（注意，这里的分发都要通过OS进行传递）。


### 3. 交互逻辑顺序 (Interaction Flow)

一个标准的游戏回合（Turn）按以下顺序严格执行：

1.  **输入拦截 (Input Filter):**
    * User 输入 -> **逻辑审查官**。
    * *判定：* 行为是否符合故事世界逻辑？（不符合则直接驳回，结束回合）。

2.  **逻辑推演 (Simulation & Direction):**
    * **中枢** -> 呼叫 **光明会**（世界运行者 & 命运编织者）。
    
    * *命运编织者* 决定剧情走向（如：这是触发隐藏剧情的时机，要求 NPC 暴怒）。

3.  **分发指令 (Dispatch):**
    * **中枢** 将光明会的决策拆解为具体指令。
    * 指令 A -> **氛围感受者**（“描写尴尬的气氛”）。
    * 指令 B -> **NPC 演员**（“你现在很生气，台词要带刺”）。

4.  **表演生成 (Performance):**
    * **氛围感受者** & **NPC 演员** 生成各自的文本块。

5.  **输出审查 (Output Filter):**
    * 所有生成的文本 -> **逻辑审查官**。
    * *判定：* 是否有幻觉？是否有逻辑冲突？（无误则通过）。

6.  **最终反馈 (Render):**
    * **中枢** 拼接文本 -> 展示给 User。

逻辑设计：
    Step 1: 统一入口 (User Input)•流程: User 输入原始文本 -> OS。Step 2: 逻辑前置审查 (Input Check)•流程: OS -> Logic (Request Check)。•Payload: User 原始输入 + 当前世界状态的简要上下文。Step 3: 校验反馈与启动决策 (Validation & Context Sync)•流程: Logic -> OS (Response: [Validated Input] / [Error Flag])。•If Valid: OS 同时向 WS 和 Vibe 索取最新上下文记录。Step 4: 汇聚与剧本编织 (Decision Making)•流程: OS 汇聚所有有效 Payload (Validated Input + WS Context + Vibe Context) -> Plot。•输出: Plot 综合信息，生成包含多重指令的新剧本指令 (JSON)。Step 5: 结果分发与状态更新 (Dispatch Instructions)•流程: Plot -> OS（发送新剧本指令）。•分发: OS -> The Cast（表演指令）/ WS（状态更新）/ Vibe（记录更新）。Step 6: 演绎与最终输出 (Enactment & Output)•流程: The Cast / Vibe 根据指令演绎情景文本 -> OS（发送最终文本）。•最终输出: OS 包装整合后的情景文本 -> User。

智能体间的信息传递的数据结构为json格式，所有数据都要流经信息中枢agent即'OS'。